/******************************************************************************
 * This file was generated by langium-cli 1.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type ClassificationTestOperator = '@' | 'hastype' | 'istype';

export type EqualityOperator = '!=' | '!==' | '==' | '===';

export type FeatureDirectionKind = 'in' | 'inout' | 'out';

export type FeatureRelationship = FeatureChaining | FeatureInverting | TypeFeaturing | TypeRelationship;

export const FeatureRelationship = 'FeatureRelationship';

export function isFeatureRelationship(item: unknown): item is FeatureRelationship {
    return reflection.isInstance(item, FeatureRelationship);
}

export type ImportKind = '::*' | '::**' | '::*::**';

export type InlineExpression = CollectExpression | FeatureChainExpression | FeatureReferenceExpression | InvocationExpression | LiteralExpression | MetadataAccessExpression | NullExpression | OperatorExpression | SelectExpression;

export const InlineExpression = 'InlineExpression';

export function isInlineExpression(item: unknown): item is InlineExpression {
    return reflection.isInstance(item, InlineExpression);
}

export type Name = string;

export function isName(item: unknown): item is Name {
    return (typeof item === 'string' && (/[_a-zA-Z][\w_\d]*/.test(item) || /'(\\['"bftnr\\]|[^'\\])*'/.test(item)));
}

export type NonOwnerType = Annotation | Membership;

export const NonOwnerType = 'NonOwnerType';

export function isNonOwnerType(item: unknown): item is NonOwnerType {
    return reflection.isInstance(item, NonOwnerType);
}

export type ParameterKind = 'actor' | 'stakeholder';

export type PortionKind = 'snapshot' | 'timeslice';

export type RelationalOperator = '<' | '<=' | '>' | '>=';

export type RequirementConstraintKind = 'assume' | 'require';

export type RequirementKind = 'objective' | 'verify';

export type StateSubactionKind = 'do' | 'entry' | 'exit';

export type TransitionFeatureKind = 'effect' | 'guard' | 'trigger';

export type TransparentElement = LoopActionUsage | NonOwnerType;

export const TransparentElement = 'TransparentElement';

export function isTransparentElement(item: unknown): item is TransparentElement {
    return reflection.isInstance(item, TransparentElement);
}

export type TriggerKind = 'after' | 'at' | 'when';

export type TypeRelationship = Differencing | Disjoining | Intersecting | Unioning;

export const TypeRelationship = 'TypeRelationship';

export function isTypeRelationship(item: unknown): item is TypeRelationship {
    return reflection.isInstance(item, TypeRelationship);
}

export type UnaryOperator = '+' | '-' | 'not' | '~';

export type VisibilityKind = 'private' | 'protected' | 'public';

export interface Element extends AstNode {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AcceptActionUsage' | 'ActionDefinition' | 'ActionUsage' | 'ActorMembership' | 'AllocationDefinition' | 'AllocationUsage' | 'AnalysisCaseDefinition' | 'AnalysisCaseUsage' | 'AnnotatingElement' | 'Annotation' | 'AssertConstraintUsage' | 'AssignmentActionUsage' | 'Association' | 'AssociationStructure' | 'AttributeDefinition' | 'AttributeUsage' | 'Behavior' | 'BindingConnector' | 'BindingConnectorAsUsage' | 'BooleanExpression' | 'CalculationDefinition' | 'CalculationUsage' | 'CaseDefinition' | 'CaseUsage' | 'Class' | 'Classifier' | 'CollectExpression' | 'Comment' | 'ConcernDefinition' | 'ConcernUsage' | 'ConjugatedPortDefinition' | 'ConjugatedPortTyping' | 'Conjugation' | 'ConnectionDefinition' | 'ConnectionUsage' | 'Connector' | 'ConnectorAsUsage' | 'ConstraintDefinition' | 'ConstraintUsage' | 'ControlNode' | 'DataType' | 'DecisionNode' | 'Definition' | 'Dependency' | 'Differencing' | 'Disjoining' | 'Documentation' | 'Element' | 'ElementFilterMembership' | 'EndFeatureMembership' | 'EnumerationDefinition' | 'EnumerationUsage' | 'EventOccurrenceUsage' | 'ExhibitStateUsage' | 'Expose' | 'Expression' | 'Feature' | 'FeatureChainExpression' | 'FeatureChaining' | 'FeatureInverting' | 'FeatureMembership' | 'FeatureReferenceExpression' | 'FeatureTyping' | 'FeatureValue' | 'Featuring' | 'FlowConnectionDefinition' | 'FlowConnectionUsage' | 'ForLoopActionUsage' | 'ForkNode' | 'FramedConcernMembership' | 'IfActionUsage' | 'Import' | 'IncludeUseCaseUsage' | 'Inheritance' | 'Interaction' | 'InterfaceDefinition' | 'InterfaceUsage' | 'Intersecting' | 'Invariant' | 'InvocationExpression' | 'ItemDefinition' | 'ItemFeature' | 'ItemFlow' | 'ItemFlowEnd' | 'ItemUsage' | 'JoinNode' | 'LibraryPackage' | 'LifeClass' | 'LiteralBoolean' | 'LiteralExpression' | 'LiteralInfinity' | 'LiteralNumber' | 'LiteralString' | 'LoopActionUsage' | 'Membership' | 'MembershipExpose' | 'MembershipImport' | 'MergeNode' | 'Metaclass' | 'MetadataAccessExpression' | 'MetadataDefinition' | 'MetadataFeature' | 'MetadataUsage' | 'Multiplicity' | 'MultiplicityRange' | 'Namespace' | 'NamespaceExpose' | 'NamespaceImport' | 'NullExpression' | 'ObjectiveMembership' | 'OccurrenceDefinition' | 'OccurrenceUsage' | 'OperatorExpression' | 'OwningMembership' | 'Package' | 'ParameterMembership' | 'PartDefinition' | 'PartUsage' | 'PerformActionUsage' | 'PortConjugation' | 'PortDefinition' | 'PortUsage' | 'Predicate' | 'Redefinition' | 'ReferenceSubsetting' | 'ReferenceUsage' | 'Relationship' | 'RenderingDefinition' | 'RenderingUsage' | 'RequirementConstraintMembership' | 'RequirementDefinition' | 'RequirementUsage' | 'RequirementVerificationMembership' | 'ResultExpressionMembership' | 'ReturnParameterMembership' | 'SatisfyRequirementUsage' | 'SelectExpression' | 'SendActionUsage' | 'Specialization' | 'StakeholderMembership' | 'StateDefinition' | 'StateSubactionMembership' | 'StateUsage' | 'Step' | 'Structure' | 'Subclassification' | 'SubjectMembership' | 'Subsetting' | 'Succession' | 'SuccessionAsUsage' | 'SuccessionFlowConnectionUsage' | 'SuccessionItemFlow' | 'SysMLFunction' | 'TextualAnnotatingElement' | 'TextualRepresentation' | 'TransitionFeatureMembership' | 'TransitionUsage' | 'TriggerInvocationExpression' | 'Type' | 'TypeFeaturing' | 'Unioning' | 'Usage' | 'UseCaseDefinition' | 'UseCaseUsage' | 'VariantMembership' | 'VerificationCaseDefinition' | 'VerificationCaseUsage' | 'ViewDefinition' | 'ViewRenderingMembership' | 'ViewUsage' | 'ViewpointDefinition' | 'ViewpointUsage' | 'WhileLoopActionUsage';
    declaredName?: string
    declaredShortName?: string
}

export const Element = 'Element';

export function isElement(item: unknown): item is Element {
    return reflection.isInstance(item, Element);
}

export interface ElementReference extends AstNode {
    readonly $container: Dependency | MetadataAccessExpression | Relationship;
    readonly $type: 'ClassifierReference' | 'ConjugatedPortReference' | 'ElementReference' | 'FeatureReference' | 'MembershipReference' | 'MetaclassReference' | 'NamespaceReference' | 'TypeReference';
    parts: Array<Reference<Element>>
}

export const ElementReference = 'ElementReference';

export function isElementReference(item: unknown): item is ElementReference {
    return reflection.isInstance(item, ElementReference);
}

export interface AnnotatingElement extends Element {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AnnotatingElement' | 'Comment' | 'Documentation' | 'MetadataFeature' | 'MetadataUsage' | 'TextualAnnotatingElement' | 'TextualRepresentation';
    about: Array<Annotation>
}

export const AnnotatingElement = 'AnnotatingElement';

export function isAnnotatingElement(item: unknown): item is AnnotatingElement {
    return reflection.isInstance(item, AnnotatingElement);
}

export interface Namespace extends Element {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AcceptActionUsage' | 'ActionDefinition' | 'ActionUsage' | 'AllocationDefinition' | 'AllocationUsage' | 'AnalysisCaseDefinition' | 'AnalysisCaseUsage' | 'AssertConstraintUsage' | 'AssignmentActionUsage' | 'Association' | 'AssociationStructure' | 'AttributeDefinition' | 'AttributeUsage' | 'Behavior' | 'BindingConnector' | 'BindingConnectorAsUsage' | 'BooleanExpression' | 'CalculationDefinition' | 'CalculationUsage' | 'CaseDefinition' | 'CaseUsage' | 'Class' | 'Classifier' | 'CollectExpression' | 'ConcernDefinition' | 'ConcernUsage' | 'ConjugatedPortDefinition' | 'ConnectionDefinition' | 'ConnectionUsage' | 'Connector' | 'ConnectorAsUsage' | 'ConstraintDefinition' | 'ConstraintUsage' | 'ControlNode' | 'DataType' | 'DecisionNode' | 'Definition' | 'EnumerationDefinition' | 'EnumerationUsage' | 'EventOccurrenceUsage' | 'ExhibitStateUsage' | 'Expression' | 'Feature' | 'FeatureChainExpression' | 'FeatureReferenceExpression' | 'FlowConnectionDefinition' | 'FlowConnectionUsage' | 'ForLoopActionUsage' | 'ForkNode' | 'IfActionUsage' | 'IncludeUseCaseUsage' | 'Interaction' | 'InterfaceDefinition' | 'InterfaceUsage' | 'Invariant' | 'InvocationExpression' | 'ItemDefinition' | 'ItemFeature' | 'ItemFlow' | 'ItemFlowEnd' | 'ItemUsage' | 'JoinNode' | 'LibraryPackage' | 'LifeClass' | 'LiteralBoolean' | 'LiteralExpression' | 'LiteralInfinity' | 'LiteralNumber' | 'LiteralString' | 'LoopActionUsage' | 'MergeNode' | 'Metaclass' | 'MetadataAccessExpression' | 'MetadataDefinition' | 'MetadataFeature' | 'MetadataUsage' | 'Multiplicity' | 'MultiplicityRange' | 'Namespace' | 'NullExpression' | 'OccurrenceDefinition' | 'OccurrenceUsage' | 'OperatorExpression' | 'Package' | 'PartDefinition' | 'PartUsage' | 'PerformActionUsage' | 'PortDefinition' | 'PortUsage' | 'Predicate' | 'ReferenceUsage' | 'RenderingDefinition' | 'RenderingUsage' | 'RequirementDefinition' | 'RequirementUsage' | 'SatisfyRequirementUsage' | 'SelectExpression' | 'SendActionUsage' | 'StateDefinition' | 'StateUsage' | 'Step' | 'Structure' | 'Succession' | 'SuccessionAsUsage' | 'SuccessionFlowConnectionUsage' | 'SuccessionItemFlow' | 'SysMLFunction' | 'TransitionUsage' | 'TriggerInvocationExpression' | 'Type' | 'Usage' | 'UseCaseDefinition' | 'UseCaseUsage' | 'VerificationCaseDefinition' | 'VerificationCaseUsage' | 'ViewDefinition' | 'ViewUsage' | 'ViewpointDefinition' | 'ViewpointUsage' | 'WhileLoopActionUsage';
    children: Array<Import | Membership>
    prefixes: Array<OwningMembership>
}

export const Namespace = 'Namespace';

export function isNamespace(item: unknown): item is Namespace {
    return reflection.isInstance(item, Namespace);
}

export interface Relationship extends Element {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActorMembership' | 'AllocationDefinition' | 'AllocationUsage' | 'Annotation' | 'Association' | 'AssociationStructure' | 'BindingConnector' | 'BindingConnectorAsUsage' | 'ConjugatedPortTyping' | 'Conjugation' | 'ConnectionDefinition' | 'ConnectionUsage' | 'Connector' | 'ConnectorAsUsage' | 'Dependency' | 'Differencing' | 'Disjoining' | 'ElementFilterMembership' | 'EndFeatureMembership' | 'Expose' | 'FeatureChaining' | 'FeatureInverting' | 'FeatureMembership' | 'FeatureTyping' | 'FeatureValue' | 'Featuring' | 'FlowConnectionDefinition' | 'FlowConnectionUsage' | 'FramedConcernMembership' | 'Import' | 'Inheritance' | 'Interaction' | 'InterfaceDefinition' | 'InterfaceUsage' | 'Intersecting' | 'ItemFlow' | 'Membership' | 'MembershipExpose' | 'MembershipImport' | 'NamespaceExpose' | 'NamespaceImport' | 'ObjectiveMembership' | 'OwningMembership' | 'ParameterMembership' | 'PortConjugation' | 'Redefinition' | 'ReferenceSubsetting' | 'Relationship' | 'RequirementConstraintMembership' | 'RequirementVerificationMembership' | 'ResultExpressionMembership' | 'ReturnParameterMembership' | 'Specialization' | 'StakeholderMembership' | 'StateSubactionMembership' | 'Subclassification' | 'SubjectMembership' | 'Subsetting' | 'Succession' | 'SuccessionAsUsage' | 'SuccessionFlowConnectionUsage' | 'SuccessionItemFlow' | 'TransitionFeatureMembership' | 'TypeFeaturing' | 'Unioning' | 'VariantMembership' | 'ViewRenderingMembership';
    elements: Array<Annotation | Feature | Namespace | Relationship>
    source?: Element
    sourceChain?: Feature
    sourceRef?: ElementReference
    target?: Element
    targetChain?: Feature
    targetRef?: ElementReference
    visibility?: VisibilityKind
}

export const Relationship = 'Relationship';

export function isRelationship(item: unknown): item is Relationship {
    return reflection.isInstance(item, Relationship);
}

export interface MembershipReference extends ElementReference {
    readonly $container: Dependency | MetadataAccessExpression | Relationship;
    readonly $type: 'MembershipReference';
}

export const MembershipReference = 'MembershipReference';

export function isMembershipReference(item: unknown): item is MembershipReference {
    return reflection.isInstance(item, MembershipReference);
}

export interface NamespaceReference extends ElementReference {
    readonly $container: Dependency | MetadataAccessExpression | Relationship;
    readonly $type: 'ClassifierReference' | 'ConjugatedPortReference' | 'FeatureReference' | 'MetaclassReference' | 'NamespaceReference' | 'TypeReference';
}

export const NamespaceReference = 'NamespaceReference';

export function isNamespaceReference(item: unknown): item is NamespaceReference {
    return reflection.isInstance(item, NamespaceReference);
}

export interface MetadataFeature extends AnnotatingElement, Feature {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'MetadataFeature' | 'MetadataUsage';
}

export const MetadataFeature = 'MetadataFeature';

export function isMetadataFeature(item: unknown): item is MetadataFeature {
    return reflection.isInstance(item, MetadataFeature);
}

export interface TextualAnnotatingElement extends AnnotatingElement {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Comment' | 'Documentation' | 'TextualAnnotatingElement' | 'TextualRepresentation';
    body: string
}

export const TextualAnnotatingElement = 'TextualAnnotatingElement';

export function isTextualAnnotatingElement(item: unknown): item is TextualAnnotatingElement {
    return reflection.isInstance(item, TextualAnnotatingElement);
}

export interface Package extends Namespace {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'LibraryPackage' | 'Package';
}

export const Package = 'Package';

export function isPackage(item: unknown): item is Package {
    return reflection.isInstance(item, Package);
}

export interface Type extends Namespace {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AcceptActionUsage' | 'ActionDefinition' | 'ActionUsage' | 'AllocationDefinition' | 'AllocationUsage' | 'AnalysisCaseDefinition' | 'AnalysisCaseUsage' | 'AssertConstraintUsage' | 'AssignmentActionUsage' | 'Association' | 'AssociationStructure' | 'AttributeDefinition' | 'AttributeUsage' | 'Behavior' | 'BindingConnector' | 'BindingConnectorAsUsage' | 'BooleanExpression' | 'CalculationDefinition' | 'CalculationUsage' | 'CaseDefinition' | 'CaseUsage' | 'Class' | 'Classifier' | 'CollectExpression' | 'ConcernDefinition' | 'ConcernUsage' | 'ConjugatedPortDefinition' | 'ConnectionDefinition' | 'ConnectionUsage' | 'Connector' | 'ConnectorAsUsage' | 'ConstraintDefinition' | 'ConstraintUsage' | 'ControlNode' | 'DataType' | 'DecisionNode' | 'Definition' | 'EnumerationDefinition' | 'EnumerationUsage' | 'EventOccurrenceUsage' | 'ExhibitStateUsage' | 'Expression' | 'Feature' | 'FeatureChainExpression' | 'FeatureReferenceExpression' | 'FlowConnectionDefinition' | 'FlowConnectionUsage' | 'ForLoopActionUsage' | 'ForkNode' | 'IfActionUsage' | 'IncludeUseCaseUsage' | 'Interaction' | 'InterfaceDefinition' | 'InterfaceUsage' | 'Invariant' | 'InvocationExpression' | 'ItemDefinition' | 'ItemFeature' | 'ItemFlow' | 'ItemFlowEnd' | 'ItemUsage' | 'JoinNode' | 'LifeClass' | 'LiteralBoolean' | 'LiteralExpression' | 'LiteralInfinity' | 'LiteralNumber' | 'LiteralString' | 'LoopActionUsage' | 'MergeNode' | 'Metaclass' | 'MetadataAccessExpression' | 'MetadataDefinition' | 'MetadataFeature' | 'MetadataUsage' | 'Multiplicity' | 'MultiplicityRange' | 'NullExpression' | 'OccurrenceDefinition' | 'OccurrenceUsage' | 'OperatorExpression' | 'PartDefinition' | 'PartUsage' | 'PerformActionUsage' | 'PortDefinition' | 'PortUsage' | 'Predicate' | 'ReferenceUsage' | 'RenderingDefinition' | 'RenderingUsage' | 'RequirementDefinition' | 'RequirementUsage' | 'SatisfyRequirementUsage' | 'SelectExpression' | 'SendActionUsage' | 'StateDefinition' | 'StateUsage' | 'Step' | 'Structure' | 'Succession' | 'SuccessionAsUsage' | 'SuccessionFlowConnectionUsage' | 'SuccessionItemFlow' | 'SysMLFunction' | 'TransitionUsage' | 'TriggerInvocationExpression' | 'Type' | 'Usage' | 'UseCaseDefinition' | 'UseCaseUsage' | 'VerificationCaseDefinition' | 'VerificationCaseUsage' | 'ViewDefinition' | 'ViewUsage' | 'ViewpointDefinition' | 'ViewpointUsage' | 'WhileLoopActionUsage';
    heritage: Array<Inheritance>
    isAbstract?: 'abstract'
    isSufficient: boolean
    multiplicity?: OwningMembership
    typeRelationships: Array<FeatureRelationship | TypeRelationship>
}

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export interface Annotation extends Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Annotation';
}

export const Annotation = 'Annotation';

export function isAnnotation(item: unknown): item is Annotation {
    return reflection.isInstance(item, Annotation);
}

export interface Association extends Classifier, Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationDefinition' | 'Association' | 'AssociationStructure' | 'ConnectionDefinition' | 'FlowConnectionDefinition' | 'Interaction' | 'InterfaceDefinition';
}

export const Association = 'Association';

export function isAssociation(item: unknown): item is Association {
    return reflection.isInstance(item, Association);
}

export interface Connector extends Feature, Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationUsage' | 'BindingConnector' | 'BindingConnectorAsUsage' | 'ConnectionUsage' | 'Connector' | 'ConnectorAsUsage' | 'FlowConnectionUsage' | 'InterfaceUsage' | 'ItemFlow' | 'Succession' | 'SuccessionAsUsage' | 'SuccessionFlowConnectionUsage' | 'SuccessionItemFlow';
    ends: Array<EndFeatureMembership>
}

export const Connector = 'Connector';

export function isConnector(item: unknown): item is Connector {
    return reflection.isInstance(item, Connector);
}

export interface Dependency extends Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Dependency';
    client: Array<ElementReference>
    prefixes: Array<Annotation>
    supplier: Array<ElementReference>
}

export const Dependency = 'Dependency';

export function isDependency(item: unknown): item is Dependency {
    return reflection.isInstance(item, Dependency);
}

export interface Differencing extends Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Differencing';
}

export const Differencing = 'Differencing';

export function isDifferencing(item: unknown): item is Differencing {
    return reflection.isInstance(item, Differencing);
}

export interface Disjoining extends Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Disjoining';
}

export const Disjoining = 'Disjoining';

export function isDisjoining(item: unknown): item is Disjoining {
    return reflection.isInstance(item, Disjoining);
}

export interface FeatureChaining extends Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'FeatureChaining';
}

export const FeatureChaining = 'FeatureChaining';

export function isFeatureChaining(item: unknown): item is FeatureChaining {
    return reflection.isInstance(item, FeatureChaining);
}

export interface FeatureInverting extends Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'FeatureInverting';
}

export const FeatureInverting = 'FeatureInverting';

export function isFeatureInverting(item: unknown): item is FeatureInverting {
    return reflection.isInstance(item, FeatureInverting);
}

export interface Featuring extends Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActorMembership' | 'EndFeatureMembership' | 'FeatureMembership' | 'Featuring' | 'FramedConcernMembership' | 'ObjectiveMembership' | 'ParameterMembership' | 'RequirementConstraintMembership' | 'RequirementVerificationMembership' | 'ResultExpressionMembership' | 'ReturnParameterMembership' | 'StakeholderMembership' | 'StateSubactionMembership' | 'SubjectMembership' | 'TransitionFeatureMembership' | 'TypeFeaturing' | 'ViewRenderingMembership';
}

export const Featuring = 'Featuring';

export function isFeaturing(item: unknown): item is Featuring {
    return reflection.isInstance(item, Featuring);
}

export interface Import extends Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Expose' | 'Import' | 'MembershipExpose' | 'MembershipImport' | 'NamespaceExpose' | 'NamespaceImport';
    importsAll: boolean
    isNamespace?: '::*'
    isRecursive: boolean
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface Inheritance extends Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ConjugatedPortTyping' | 'Conjugation' | 'FeatureTyping' | 'Inheritance' | 'PortConjugation' | 'Redefinition' | 'ReferenceSubsetting' | 'Specialization' | 'Subclassification' | 'Subsetting';
}

export const Inheritance = 'Inheritance';

export function isInheritance(item: unknown): item is Inheritance {
    return reflection.isInstance(item, Inheritance);
}

export interface Intersecting extends Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Intersecting';
}

export const Intersecting = 'Intersecting';

export function isIntersecting(item: unknown): item is Intersecting {
    return reflection.isInstance(item, Intersecting);
}

export interface Membership extends Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActorMembership' | 'ElementFilterMembership' | 'EndFeatureMembership' | 'FeatureMembership' | 'FeatureValue' | 'FramedConcernMembership' | 'Membership' | 'ObjectiveMembership' | 'OwningMembership' | 'ParameterMembership' | 'RequirementConstraintMembership' | 'RequirementVerificationMembership' | 'ResultExpressionMembership' | 'ReturnParameterMembership' | 'StakeholderMembership' | 'StateSubactionMembership' | 'SubjectMembership' | 'TransitionFeatureMembership' | 'VariantMembership' | 'ViewRenderingMembership';
    isAlias: boolean
}

export const Membership = 'Membership';

export function isMembership(item: unknown): item is Membership {
    return reflection.isInstance(item, Membership);
}

export interface Unioning extends Relationship {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Unioning';
}

export const Unioning = 'Unioning';

export function isUnioning(item: unknown): item is Unioning {
    return reflection.isInstance(item, Unioning);
}

export interface TypeReference extends NamespaceReference {
    readonly $container: Dependency | MetadataAccessExpression | Relationship;
    readonly $type: 'ClassifierReference' | 'ConjugatedPortReference' | 'FeatureReference' | 'MetaclassReference' | 'TypeReference';
}

export const TypeReference = 'TypeReference';

export function isTypeReference(item: unknown): item is TypeReference {
    return reflection.isInstance(item, TypeReference);
}

export interface MetadataUsage extends ItemUsage, MetadataFeature {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'MetadataUsage';
}

export const MetadataUsage = 'MetadataUsage';

export function isMetadataUsage(item: unknown): item is MetadataUsage {
    return reflection.isInstance(item, MetadataUsage);
}

export interface Comment extends TextualAnnotatingElement {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Comment' | 'Documentation';
}

export const Comment = 'Comment';

export function isComment(item: unknown): item is Comment {
    return reflection.isInstance(item, Comment);
}

export interface TextualRepresentation extends TextualAnnotatingElement {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'TextualRepresentation';
    language: string
}

export const TextualRepresentation = 'TextualRepresentation';

export function isTextualRepresentation(item: unknown): item is TextualRepresentation {
    return reflection.isInstance(item, TextualRepresentation);
}

export interface LibraryPackage extends Package {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'LibraryPackage';
    isStandard: boolean
}

export const LibraryPackage = 'LibraryPackage';

export function isLibraryPackage(item: unknown): item is LibraryPackage {
    return reflection.isInstance(item, LibraryPackage);
}

export interface Classifier extends Type {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActionDefinition' | 'AllocationDefinition' | 'AnalysisCaseDefinition' | 'Association' | 'AssociationStructure' | 'AttributeDefinition' | 'Behavior' | 'CalculationDefinition' | 'CaseDefinition' | 'Class' | 'Classifier' | 'ConcernDefinition' | 'ConjugatedPortDefinition' | 'ConnectionDefinition' | 'ConstraintDefinition' | 'DataType' | 'Definition' | 'EnumerationDefinition' | 'FlowConnectionDefinition' | 'Interaction' | 'InterfaceDefinition' | 'ItemDefinition' | 'LifeClass' | 'Metaclass' | 'MetadataDefinition' | 'OccurrenceDefinition' | 'PartDefinition' | 'PortDefinition' | 'Predicate' | 'RenderingDefinition' | 'RequirementDefinition' | 'StateDefinition' | 'Structure' | 'SysMLFunction' | 'UseCaseDefinition' | 'VerificationCaseDefinition' | 'ViewDefinition' | 'ViewpointDefinition';
}

export const Classifier = 'Classifier';

export function isClassifier(item: unknown): item is Classifier {
    return reflection.isInstance(item, Classifier);
}

export interface Feature extends Type {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AcceptActionUsage' | 'ActionUsage' | 'AllocationUsage' | 'AnalysisCaseUsage' | 'AssertConstraintUsage' | 'AssignmentActionUsage' | 'AttributeUsage' | 'BindingConnector' | 'BindingConnectorAsUsage' | 'BooleanExpression' | 'CalculationUsage' | 'CaseUsage' | 'CollectExpression' | 'ConcernUsage' | 'ConnectionUsage' | 'Connector' | 'ConnectorAsUsage' | 'ConstraintUsage' | 'ControlNode' | 'DecisionNode' | 'EnumerationUsage' | 'EventOccurrenceUsage' | 'ExhibitStateUsage' | 'Expression' | 'Feature' | 'FeatureChainExpression' | 'FeatureReferenceExpression' | 'FlowConnectionUsage' | 'ForLoopActionUsage' | 'ForkNode' | 'IfActionUsage' | 'IncludeUseCaseUsage' | 'InterfaceUsage' | 'Invariant' | 'InvocationExpression' | 'ItemFeature' | 'ItemFlow' | 'ItemFlowEnd' | 'ItemUsage' | 'JoinNode' | 'LiteralBoolean' | 'LiteralExpression' | 'LiteralInfinity' | 'LiteralNumber' | 'LiteralString' | 'LoopActionUsage' | 'MergeNode' | 'MetadataAccessExpression' | 'MetadataFeature' | 'MetadataUsage' | 'Multiplicity' | 'MultiplicityRange' | 'NullExpression' | 'OccurrenceUsage' | 'OperatorExpression' | 'PartUsage' | 'PerformActionUsage' | 'PortUsage' | 'ReferenceUsage' | 'RenderingUsage' | 'RequirementUsage' | 'SatisfyRequirementUsage' | 'SelectExpression' | 'SendActionUsage' | 'StateUsage' | 'Step' | 'Succession' | 'SuccessionAsUsage' | 'SuccessionFlowConnectionUsage' | 'SuccessionItemFlow' | 'TransitionUsage' | 'TriggerInvocationExpression' | 'Usage' | 'UseCaseUsage' | 'VerificationCaseUsage' | 'ViewUsage' | 'ViewpointUsage' | 'WhileLoopActionUsage';
    direction?: FeatureDirectionKind
    isComposite?: 'composite'
    isDerived?: 'derived'
    isEnd?: 'end'
    isNonunique: boolean
    isOrdered: boolean
    isPortion?: 'portion'
    isReadOnly?: 'readonly'
    value?: FeatureValue
    write?: Membership
}

export const Feature = 'Feature';

export function isFeature(item: unknown): item is Feature {
    return reflection.isInstance(item, Feature);
}

export interface AssociationStructure extends Association, Structure {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationDefinition' | 'AssociationStructure' | 'ConnectionDefinition' | 'FlowConnectionDefinition' | 'InterfaceDefinition';
}

export const AssociationStructure = 'AssociationStructure';

export function isAssociationStructure(item: unknown): item is AssociationStructure {
    return reflection.isInstance(item, AssociationStructure);
}

export interface Interaction extends Association, Behavior {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'FlowConnectionDefinition' | 'Interaction';
}

export const Interaction = 'Interaction';

export function isInteraction(item: unknown): item is Interaction {
    return reflection.isInstance(item, Interaction);
}

export interface BindingConnector extends Connector {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'BindingConnector' | 'BindingConnectorAsUsage';
}

export const BindingConnector = 'BindingConnector';

export function isBindingConnector(item: unknown): item is BindingConnector {
    return reflection.isInstance(item, BindingConnector);
}

export interface ConnectorAsUsage extends Connector, Usage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationUsage' | 'BindingConnectorAsUsage' | 'ConnectionUsage' | 'ConnectorAsUsage' | 'FlowConnectionUsage' | 'InterfaceUsage' | 'SuccessionAsUsage' | 'SuccessionFlowConnectionUsage';
}

export const ConnectorAsUsage = 'ConnectorAsUsage';

export function isConnectorAsUsage(item: unknown): item is ConnectorAsUsage {
    return reflection.isInstance(item, ConnectorAsUsage);
}

export interface ItemFlow extends Connector, Step {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'FlowConnectionUsage' | 'ItemFlow' | 'SuccessionFlowConnectionUsage' | 'SuccessionItemFlow';
    item?: FeatureMembership
}

export const ItemFlow = 'ItemFlow';

export function isItemFlow(item: unknown): item is ItemFlow {
    return reflection.isInstance(item, ItemFlow);
}

export interface Succession extends Connector {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Succession' | 'SuccessionAsUsage' | 'SuccessionFlowConnectionUsage' | 'SuccessionItemFlow';
}

export const Succession = 'Succession';

export function isSuccession(item: unknown): item is Succession {
    return reflection.isInstance(item, Succession);
}

export interface FeatureMembership extends Featuring, OwningMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActorMembership' | 'EndFeatureMembership' | 'FeatureMembership' | 'FramedConcernMembership' | 'ObjectiveMembership' | 'ParameterMembership' | 'RequirementConstraintMembership' | 'RequirementVerificationMembership' | 'ResultExpressionMembership' | 'ReturnParameterMembership' | 'StakeholderMembership' | 'StateSubactionMembership' | 'SubjectMembership' | 'TransitionFeatureMembership' | 'ViewRenderingMembership';
}

export const FeatureMembership = 'FeatureMembership';

export function isFeatureMembership(item: unknown): item is FeatureMembership {
    return reflection.isInstance(item, FeatureMembership);
}

export interface TypeFeaturing extends Featuring {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'TypeFeaturing';
}

export const TypeFeaturing = 'TypeFeaturing';

export function isTypeFeaturing(item: unknown): item is TypeFeaturing {
    return reflection.isInstance(item, TypeFeaturing);
}

export interface Expose extends Import {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Expose' | 'MembershipExpose' | 'NamespaceExpose';
}

export const Expose = 'Expose';

export function isExpose(item: unknown): item is Expose {
    return reflection.isInstance(item, Expose);
}

export interface MembershipImport extends Import {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'MembershipExpose' | 'MembershipImport';
}

export const MembershipImport = 'MembershipImport';

export function isMembershipImport(item: unknown): item is MembershipImport {
    return reflection.isInstance(item, MembershipImport);
}

export interface NamespaceImport extends Import {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'NamespaceExpose' | 'NamespaceImport';
}

export const NamespaceImport = 'NamespaceImport';

export function isNamespaceImport(item: unknown): item is NamespaceImport {
    return reflection.isInstance(item, NamespaceImport);
}

export interface Conjugation extends Inheritance {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Conjugation' | 'PortConjugation';
}

export const Conjugation = 'Conjugation';

export function isConjugation(item: unknown): item is Conjugation {
    return reflection.isInstance(item, Conjugation);
}

export interface Specialization extends Inheritance {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ConjugatedPortTyping' | 'FeatureTyping' | 'Redefinition' | 'ReferenceSubsetting' | 'Specialization' | 'Subclassification' | 'Subsetting';
}

export const Specialization = 'Specialization';

export function isSpecialization(item: unknown): item is Specialization {
    return reflection.isInstance(item, Specialization);
}

export interface OwningMembership extends Membership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActorMembership' | 'ElementFilterMembership' | 'EndFeatureMembership' | 'FeatureMembership' | 'FeatureValue' | 'FramedConcernMembership' | 'ObjectiveMembership' | 'OwningMembership' | 'ParameterMembership' | 'RequirementConstraintMembership' | 'RequirementVerificationMembership' | 'ResultExpressionMembership' | 'ReturnParameterMembership' | 'StakeholderMembership' | 'StateSubactionMembership' | 'SubjectMembership' | 'TransitionFeatureMembership' | 'VariantMembership' | 'ViewRenderingMembership';
}

export const OwningMembership = 'OwningMembership';

export function isOwningMembership(item: unknown): item is OwningMembership {
    return reflection.isInstance(item, OwningMembership);
}

export interface ClassifierReference extends TypeReference {
    readonly $container: Dependency | MetadataAccessExpression | Relationship;
    readonly $type: 'ClassifierReference' | 'ConjugatedPortReference' | 'MetaclassReference';
}

export const ClassifierReference = 'ClassifierReference';

export function isClassifierReference(item: unknown): item is ClassifierReference {
    return reflection.isInstance(item, ClassifierReference);
}

export interface FeatureReference extends TypeReference {
    readonly $container: Dependency | MetadataAccessExpression | Relationship;
    readonly $type: 'FeatureReference';
}

export const FeatureReference = 'FeatureReference';

export function isFeatureReference(item: unknown): item is FeatureReference {
    return reflection.isInstance(item, FeatureReference);
}

export interface Documentation extends Comment {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Documentation';
}

export const Documentation = 'Documentation';

export function isDocumentation(item: unknown): item is Documentation {
    return reflection.isInstance(item, Documentation);
}

export interface Class extends Classifier {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActionDefinition' | 'AllocationDefinition' | 'AnalysisCaseDefinition' | 'AssociationStructure' | 'Behavior' | 'CalculationDefinition' | 'CaseDefinition' | 'Class' | 'ConcernDefinition' | 'ConjugatedPortDefinition' | 'ConnectionDefinition' | 'ConstraintDefinition' | 'FlowConnectionDefinition' | 'Interaction' | 'InterfaceDefinition' | 'ItemDefinition' | 'LifeClass' | 'Metaclass' | 'MetadataDefinition' | 'OccurrenceDefinition' | 'PartDefinition' | 'PortDefinition' | 'Predicate' | 'RenderingDefinition' | 'RequirementDefinition' | 'StateDefinition' | 'Structure' | 'SysMLFunction' | 'UseCaseDefinition' | 'VerificationCaseDefinition' | 'ViewDefinition' | 'ViewpointDefinition';
}

export const Class = 'Class';

export function isClass(item: unknown): item is Class {
    return reflection.isInstance(item, Class);
}

export interface DataType extends Classifier {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AttributeDefinition' | 'DataType' | 'EnumerationDefinition';
}

export const DataType = 'DataType';

export function isDataType(item: unknown): item is DataType {
    return reflection.isInstance(item, DataType);
}

export interface Definition extends Classifier {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActionDefinition' | 'AllocationDefinition' | 'AnalysisCaseDefinition' | 'AttributeDefinition' | 'CalculationDefinition' | 'CaseDefinition' | 'ConcernDefinition' | 'ConjugatedPortDefinition' | 'ConnectionDefinition' | 'ConstraintDefinition' | 'Definition' | 'EnumerationDefinition' | 'FlowConnectionDefinition' | 'InterfaceDefinition' | 'ItemDefinition' | 'MetadataDefinition' | 'OccurrenceDefinition' | 'PartDefinition' | 'PortDefinition' | 'RenderingDefinition' | 'RequirementDefinition' | 'StateDefinition' | 'UseCaseDefinition' | 'VerificationCaseDefinition' | 'ViewDefinition' | 'ViewpointDefinition';
    isIndividual: boolean
    isVariation: boolean
}

export const Definition = 'Definition';

export function isDefinition(item: unknown): item is Definition {
    return reflection.isInstance(item, Definition);
}

export interface ItemFeature extends Feature {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ItemFeature';
}

export const ItemFeature = 'ItemFeature';

export function isItemFeature(item: unknown): item is ItemFeature {
    return reflection.isInstance(item, ItemFeature);
}

export interface ItemFlowEnd extends Feature {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ItemFlowEnd';
}

export const ItemFlowEnd = 'ItemFlowEnd';

export function isItemFlowEnd(item: unknown): item is ItemFlowEnd {
    return reflection.isInstance(item, ItemFlowEnd);
}

export interface Multiplicity extends Feature {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Multiplicity' | 'MultiplicityRange';
}

export const Multiplicity = 'Multiplicity';

export function isMultiplicity(item: unknown): item is Multiplicity {
    return reflection.isInstance(item, Multiplicity);
}

export interface Step extends Feature {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AcceptActionUsage' | 'ActionUsage' | 'AnalysisCaseUsage' | 'AssertConstraintUsage' | 'AssignmentActionUsage' | 'BooleanExpression' | 'CalculationUsage' | 'CaseUsage' | 'CollectExpression' | 'ConcernUsage' | 'ConstraintUsage' | 'ControlNode' | 'DecisionNode' | 'ExhibitStateUsage' | 'Expression' | 'FeatureChainExpression' | 'FeatureReferenceExpression' | 'FlowConnectionUsage' | 'ForLoopActionUsage' | 'ForkNode' | 'IfActionUsage' | 'IncludeUseCaseUsage' | 'Invariant' | 'InvocationExpression' | 'ItemFlow' | 'JoinNode' | 'LiteralBoolean' | 'LiteralExpression' | 'LiteralInfinity' | 'LiteralNumber' | 'LiteralString' | 'LoopActionUsage' | 'MergeNode' | 'MetadataAccessExpression' | 'NullExpression' | 'OperatorExpression' | 'PerformActionUsage' | 'RequirementUsage' | 'SatisfyRequirementUsage' | 'SelectExpression' | 'SendActionUsage' | 'StateUsage' | 'Step' | 'SuccessionFlowConnectionUsage' | 'SuccessionItemFlow' | 'TransitionUsage' | 'TriggerInvocationExpression' | 'UseCaseUsage' | 'VerificationCaseUsage' | 'ViewpointUsage' | 'WhileLoopActionUsage';
}

export const Step = 'Step';

export function isStep(item: unknown): item is Step {
    return reflection.isInstance(item, Step);
}

export interface Usage extends Feature {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AcceptActionUsage' | 'ActionUsage' | 'AllocationUsage' | 'AnalysisCaseUsage' | 'AssertConstraintUsage' | 'AssignmentActionUsage' | 'AttributeUsage' | 'BindingConnectorAsUsage' | 'CalculationUsage' | 'CaseUsage' | 'ConcernUsage' | 'ConnectionUsage' | 'ConnectorAsUsage' | 'ConstraintUsage' | 'ControlNode' | 'DecisionNode' | 'EnumerationUsage' | 'EventOccurrenceUsage' | 'ExhibitStateUsage' | 'FlowConnectionUsage' | 'ForLoopActionUsage' | 'ForkNode' | 'IfActionUsage' | 'IncludeUseCaseUsage' | 'InterfaceUsage' | 'ItemUsage' | 'JoinNode' | 'LoopActionUsage' | 'MergeNode' | 'MetadataUsage' | 'OccurrenceUsage' | 'PartUsage' | 'PerformActionUsage' | 'PortUsage' | 'ReferenceUsage' | 'RenderingUsage' | 'RequirementUsage' | 'SatisfyRequirementUsage' | 'SendActionUsage' | 'StateUsage' | 'SuccessionAsUsage' | 'SuccessionFlowConnectionUsage' | 'TransitionUsage' | 'Usage' | 'UseCaseUsage' | 'VerificationCaseUsage' | 'ViewUsage' | 'ViewpointUsage' | 'WhileLoopActionUsage';
    isIndividual: boolean
    isReference: boolean
    isVariation: boolean
    portionKind?: PortionKind
}

export const Usage = 'Usage';

export function isUsage(item: unknown): item is Usage {
    return reflection.isInstance(item, Usage);
}

export interface ConnectionDefinition extends AssociationStructure, PartDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationDefinition' | 'ConnectionDefinition' | 'FlowConnectionDefinition' | 'InterfaceDefinition';
}

export const ConnectionDefinition = 'ConnectionDefinition';

export function isConnectionDefinition(item: unknown): item is ConnectionDefinition {
    return reflection.isInstance(item, ConnectionDefinition);
}

export interface FlowConnectionDefinition extends ActionDefinition, ConnectionDefinition, Interaction {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'FlowConnectionDefinition';
}

export const FlowConnectionDefinition = 'FlowConnectionDefinition';

export function isFlowConnectionDefinition(item: unknown): item is FlowConnectionDefinition {
    return reflection.isInstance(item, FlowConnectionDefinition);
}

export interface BindingConnectorAsUsage extends BindingConnector, ConnectorAsUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'BindingConnectorAsUsage';
}

export const BindingConnectorAsUsage = 'BindingConnectorAsUsage';

export function isBindingConnectorAsUsage(item: unknown): item is BindingConnectorAsUsage {
    return reflection.isInstance(item, BindingConnectorAsUsage);
}

export interface ConnectionUsage extends ConnectorAsUsage, PartUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationUsage' | 'ConnectionUsage' | 'FlowConnectionUsage' | 'InterfaceUsage' | 'SuccessionFlowConnectionUsage';
}

export const ConnectionUsage = 'ConnectionUsage';

export function isConnectionUsage(item: unknown): item is ConnectionUsage {
    return reflection.isInstance(item, ConnectionUsage);
}

export interface SuccessionAsUsage extends ConnectorAsUsage, Succession {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'SuccessionAsUsage';
}

export const SuccessionAsUsage = 'SuccessionAsUsage';

export function isSuccessionAsUsage(item: unknown): item is SuccessionAsUsage {
    return reflection.isInstance(item, SuccessionAsUsage);
}

export interface FlowConnectionUsage extends ActionUsage, ConnectionUsage, ItemFlow {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'FlowConnectionUsage' | 'SuccessionFlowConnectionUsage';
    messages: Array<ParameterMembership>
}

export const FlowConnectionUsage = 'FlowConnectionUsage';

export function isFlowConnectionUsage(item: unknown): item is FlowConnectionUsage {
    return reflection.isInstance(item, FlowConnectionUsage);
}

export interface SuccessionItemFlow extends ItemFlow, Succession {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'SuccessionFlowConnectionUsage' | 'SuccessionItemFlow';
}

export const SuccessionItemFlow = 'SuccessionItemFlow';

export function isSuccessionItemFlow(item: unknown): item is SuccessionItemFlow {
    return reflection.isInstance(item, SuccessionItemFlow);
}

export interface EndFeatureMembership extends FeatureMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'EndFeatureMembership';
}

export const EndFeatureMembership = 'EndFeatureMembership';

export function isEndFeatureMembership(item: unknown): item is EndFeatureMembership {
    return reflection.isInstance(item, EndFeatureMembership);
}

export interface ObjectiveMembership extends FeatureMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ObjectiveMembership';
}

export const ObjectiveMembership = 'ObjectiveMembership';

export function isObjectiveMembership(item: unknown): item is ObjectiveMembership {
    return reflection.isInstance(item, ObjectiveMembership);
}

export interface ParameterMembership extends FeatureMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActorMembership' | 'ParameterMembership' | 'ReturnParameterMembership' | 'StakeholderMembership' | 'SubjectMembership';
}

export const ParameterMembership = 'ParameterMembership';

export function isParameterMembership(item: unknown): item is ParameterMembership {
    return reflection.isInstance(item, ParameterMembership);
}

export interface RequirementConstraintMembership extends FeatureMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'FramedConcernMembership' | 'RequirementConstraintMembership' | 'RequirementVerificationMembership';
    kind?: RequirementConstraintKind
}

export const RequirementConstraintMembership = 'RequirementConstraintMembership';

export function isRequirementConstraintMembership(item: unknown): item is RequirementConstraintMembership {
    return reflection.isInstance(item, RequirementConstraintMembership);
}

export interface ResultExpressionMembership extends FeatureMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ResultExpressionMembership';
}

export const ResultExpressionMembership = 'ResultExpressionMembership';

export function isResultExpressionMembership(item: unknown): item is ResultExpressionMembership {
    return reflection.isInstance(item, ResultExpressionMembership);
}

export interface StateSubactionMembership extends FeatureMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'StateSubactionMembership';
    kind: 'do' | 'entry' | 'exit'
}

export const StateSubactionMembership = 'StateSubactionMembership';

export function isStateSubactionMembership(item: unknown): item is StateSubactionMembership {
    return reflection.isInstance(item, StateSubactionMembership);
}

export interface TransitionFeatureMembership extends FeatureMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'TransitionFeatureMembership';
    kind: 'accept' | 'do' | 'if'
}

export const TransitionFeatureMembership = 'TransitionFeatureMembership';

export function isTransitionFeatureMembership(item: unknown): item is TransitionFeatureMembership {
    return reflection.isInstance(item, TransitionFeatureMembership);
}

export interface ViewRenderingMembership extends FeatureMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ViewRenderingMembership';
}

export const ViewRenderingMembership = 'ViewRenderingMembership';

export function isViewRenderingMembership(item: unknown): item is ViewRenderingMembership {
    return reflection.isInstance(item, ViewRenderingMembership);
}

export interface MembershipExpose extends Expose, MembershipImport {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'MembershipExpose';
}

export const MembershipExpose = 'MembershipExpose';

export function isMembershipExpose(item: unknown): item is MembershipExpose {
    return reflection.isInstance(item, MembershipExpose);
}

export interface NamespaceExpose extends Expose, NamespaceImport {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'NamespaceExpose';
}

export const NamespaceExpose = 'NamespaceExpose';

export function isNamespaceExpose(item: unknown): item is NamespaceExpose {
    return reflection.isInstance(item, NamespaceExpose);
}

export interface PortConjugation extends Conjugation {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'PortConjugation';
}

export const PortConjugation = 'PortConjugation';

export function isPortConjugation(item: unknown): item is PortConjugation {
    return reflection.isInstance(item, PortConjugation);
}

export interface FeatureTyping extends Specialization {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ConjugatedPortTyping' | 'FeatureTyping';
}

export const FeatureTyping = 'FeatureTyping';

export function isFeatureTyping(item: unknown): item is FeatureTyping {
    return reflection.isInstance(item, FeatureTyping);
}

export interface Subclassification extends Specialization {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Subclassification';
}

export const Subclassification = 'Subclassification';

export function isSubclassification(item: unknown): item is Subclassification {
    return reflection.isInstance(item, Subclassification);
}

export interface Subsetting extends Specialization {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Redefinition' | 'ReferenceSubsetting' | 'Subsetting';
}

export const Subsetting = 'Subsetting';

export function isSubsetting(item: unknown): item is Subsetting {
    return reflection.isInstance(item, Subsetting);
}

export interface ElementFilterMembership extends OwningMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ElementFilterMembership';
}

export const ElementFilterMembership = 'ElementFilterMembership';

export function isElementFilterMembership(item: unknown): item is ElementFilterMembership {
    return reflection.isInstance(item, ElementFilterMembership);
}

export interface FeatureValue extends OwningMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'FeatureValue';
    isDefault: boolean
    isInitial: boolean
}

export const FeatureValue = 'FeatureValue';

export function isFeatureValue(item: unknown): item is FeatureValue {
    return reflection.isInstance(item, FeatureValue);
}

export interface VariantMembership extends OwningMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'VariantMembership';
}

export const VariantMembership = 'VariantMembership';

export function isVariantMembership(item: unknown): item is VariantMembership {
    return reflection.isInstance(item, VariantMembership);
}

export interface ConjugatedPortReference extends ClassifierReference {
    readonly $container: Dependency | MetadataAccessExpression | Relationship;
    readonly $type: 'ConjugatedPortReference';
}

export const ConjugatedPortReference = 'ConjugatedPortReference';

export function isConjugatedPortReference(item: unknown): item is ConjugatedPortReference {
    return reflection.isInstance(item, ConjugatedPortReference);
}

export interface MetaclassReference extends ClassifierReference {
    readonly $container: Dependency | MetadataAccessExpression | Relationship;
    readonly $type: 'MetaclassReference';
}

export const MetaclassReference = 'MetaclassReference';

export function isMetaclassReference(item: unknown): item is MetaclassReference {
    return reflection.isInstance(item, MetaclassReference);
}

export interface Behavior extends Class {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActionDefinition' | 'AnalysisCaseDefinition' | 'Behavior' | 'CalculationDefinition' | 'CaseDefinition' | 'ConcernDefinition' | 'ConstraintDefinition' | 'FlowConnectionDefinition' | 'Interaction' | 'Predicate' | 'RequirementDefinition' | 'StateDefinition' | 'SysMLFunction' | 'UseCaseDefinition' | 'VerificationCaseDefinition' | 'ViewpointDefinition';
}

export const Behavior = 'Behavior';

export function isBehavior(item: unknown): item is Behavior {
    return reflection.isInstance(item, Behavior);
}

export interface LifeClass extends Class {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'LifeClass';
}

export const LifeClass = 'LifeClass';

export function isLifeClass(item: unknown): item is LifeClass {
    return reflection.isInstance(item, LifeClass);
}

export interface OccurrenceDefinition extends Class, Definition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActionDefinition' | 'AllocationDefinition' | 'AnalysisCaseDefinition' | 'CalculationDefinition' | 'CaseDefinition' | 'ConcernDefinition' | 'ConjugatedPortDefinition' | 'ConnectionDefinition' | 'ConstraintDefinition' | 'FlowConnectionDefinition' | 'InterfaceDefinition' | 'ItemDefinition' | 'MetadataDefinition' | 'OccurrenceDefinition' | 'PartDefinition' | 'PortDefinition' | 'RenderingDefinition' | 'RequirementDefinition' | 'StateDefinition' | 'UseCaseDefinition' | 'VerificationCaseDefinition' | 'ViewDefinition' | 'ViewpointDefinition';
}

export const OccurrenceDefinition = 'OccurrenceDefinition';

export function isOccurrenceDefinition(item: unknown): item is OccurrenceDefinition {
    return reflection.isInstance(item, OccurrenceDefinition);
}

export interface Structure extends Class {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationDefinition' | 'AssociationStructure' | 'ConjugatedPortDefinition' | 'ConnectionDefinition' | 'FlowConnectionDefinition' | 'InterfaceDefinition' | 'ItemDefinition' | 'Metaclass' | 'MetadataDefinition' | 'PartDefinition' | 'PortDefinition' | 'RenderingDefinition' | 'Structure' | 'ViewDefinition';
}

export const Structure = 'Structure';

export function isStructure(item: unknown): item is Structure {
    return reflection.isInstance(item, Structure);
}

export interface AttributeDefinition extends DataType, Definition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AttributeDefinition' | 'EnumerationDefinition';
}

export const AttributeDefinition = 'AttributeDefinition';

export function isAttributeDefinition(item: unknown): item is AttributeDefinition {
    return reflection.isInstance(item, AttributeDefinition);
}

export interface MultiplicityRange extends Multiplicity {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'MultiplicityRange';
    range?: OwningMembership
}

export const MultiplicityRange = 'MultiplicityRange';

export function isMultiplicityRange(item: unknown): item is MultiplicityRange {
    return reflection.isInstance(item, MultiplicityRange);
}

export interface ActionUsage extends OccurrenceUsage, Step {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AcceptActionUsage' | 'ActionUsage' | 'AnalysisCaseUsage' | 'AssignmentActionUsage' | 'CalculationUsage' | 'CaseUsage' | 'ControlNode' | 'DecisionNode' | 'ExhibitStateUsage' | 'FlowConnectionUsage' | 'ForLoopActionUsage' | 'ForkNode' | 'IfActionUsage' | 'IncludeUseCaseUsage' | 'JoinNode' | 'LoopActionUsage' | 'MergeNode' | 'PerformActionUsage' | 'SendActionUsage' | 'StateUsage' | 'SuccessionFlowConnectionUsage' | 'TransitionUsage' | 'UseCaseUsage' | 'VerificationCaseUsage' | 'WhileLoopActionUsage';
}

export const ActionUsage = 'ActionUsage';

export function isActionUsage(item: unknown): item is ActionUsage {
    return reflection.isInstance(item, ActionUsage);
}

export interface Expression extends Step {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AnalysisCaseUsage' | 'AssertConstraintUsage' | 'BooleanExpression' | 'CalculationUsage' | 'CaseUsage' | 'CollectExpression' | 'ConcernUsage' | 'ConstraintUsage' | 'Expression' | 'FeatureChainExpression' | 'FeatureReferenceExpression' | 'IncludeUseCaseUsage' | 'Invariant' | 'InvocationExpression' | 'LiteralBoolean' | 'LiteralExpression' | 'LiteralInfinity' | 'LiteralNumber' | 'LiteralString' | 'MetadataAccessExpression' | 'NullExpression' | 'OperatorExpression' | 'RequirementUsage' | 'SatisfyRequirementUsage' | 'SelectExpression' | 'TriggerInvocationExpression' | 'UseCaseUsage' | 'VerificationCaseUsage' | 'ViewpointUsage';
    result?: ResultExpressionMembership
}

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export interface AttributeUsage extends Usage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AttributeUsage' | 'EnumerationUsage';
}

export const AttributeUsage = 'AttributeUsage';

export function isAttributeUsage(item: unknown): item is AttributeUsage {
    return reflection.isInstance(item, AttributeUsage);
}

export interface OccurrenceUsage extends Usage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AcceptActionUsage' | 'ActionUsage' | 'AllocationUsage' | 'AnalysisCaseUsage' | 'AssertConstraintUsage' | 'AssignmentActionUsage' | 'CalculationUsage' | 'CaseUsage' | 'ConcernUsage' | 'ConnectionUsage' | 'ConstraintUsage' | 'ControlNode' | 'DecisionNode' | 'EventOccurrenceUsage' | 'ExhibitStateUsage' | 'FlowConnectionUsage' | 'ForLoopActionUsage' | 'ForkNode' | 'IfActionUsage' | 'IncludeUseCaseUsage' | 'InterfaceUsage' | 'ItemUsage' | 'JoinNode' | 'LoopActionUsage' | 'MergeNode' | 'MetadataUsage' | 'OccurrenceUsage' | 'PartUsage' | 'PerformActionUsage' | 'PortUsage' | 'RenderingUsage' | 'RequirementUsage' | 'SatisfyRequirementUsage' | 'SendActionUsage' | 'StateUsage' | 'SuccessionFlowConnectionUsage' | 'TransitionUsage' | 'UseCaseUsage' | 'VerificationCaseUsage' | 'ViewUsage' | 'ViewpointUsage' | 'WhileLoopActionUsage';
}

export const OccurrenceUsage = 'OccurrenceUsage';

export function isOccurrenceUsage(item: unknown): item is OccurrenceUsage {
    return reflection.isInstance(item, OccurrenceUsage);
}

export interface ReferenceUsage extends Usage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ReferenceUsage';
}

export const ReferenceUsage = 'ReferenceUsage';

export function isReferenceUsage(item: unknown): item is ReferenceUsage {
    return reflection.isInstance(item, ReferenceUsage);
}

export interface AllocationDefinition extends ConnectionDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationDefinition';
}

export const AllocationDefinition = 'AllocationDefinition';

export function isAllocationDefinition(item: unknown): item is AllocationDefinition {
    return reflection.isInstance(item, AllocationDefinition);
}

export interface InterfaceDefinition extends ConnectionDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'InterfaceDefinition';
}

export const InterfaceDefinition = 'InterfaceDefinition';

export function isInterfaceDefinition(item: unknown): item is InterfaceDefinition {
    return reflection.isInstance(item, InterfaceDefinition);
}

export interface AllocationUsage extends ConnectionUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationUsage';
}

export const AllocationUsage = 'AllocationUsage';

export function isAllocationUsage(item: unknown): item is AllocationUsage {
    return reflection.isInstance(item, AllocationUsage);
}

export interface InterfaceUsage extends ConnectionUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'InterfaceUsage';
}

export const InterfaceUsage = 'InterfaceUsage';

export function isInterfaceUsage(item: unknown): item is InterfaceUsage {
    return reflection.isInstance(item, InterfaceUsage);
}

export interface SuccessionFlowConnectionUsage extends FlowConnectionUsage, SuccessionItemFlow {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'SuccessionFlowConnectionUsage';
}

export const SuccessionFlowConnectionUsage = 'SuccessionFlowConnectionUsage';

export function isSuccessionFlowConnectionUsage(item: unknown): item is SuccessionFlowConnectionUsage {
    return reflection.isInstance(item, SuccessionFlowConnectionUsage);
}

export interface ActorMembership extends ParameterMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActorMembership';
}

export const ActorMembership = 'ActorMembership';

export function isActorMembership(item: unknown): item is ActorMembership {
    return reflection.isInstance(item, ActorMembership);
}

export interface ReturnParameterMembership extends ParameterMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ReturnParameterMembership';
}

export const ReturnParameterMembership = 'ReturnParameterMembership';

export function isReturnParameterMembership(item: unknown): item is ReturnParameterMembership {
    return reflection.isInstance(item, ReturnParameterMembership);
}

export interface StakeholderMembership extends ParameterMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'StakeholderMembership';
}

export const StakeholderMembership = 'StakeholderMembership';

export function isStakeholderMembership(item: unknown): item is StakeholderMembership {
    return reflection.isInstance(item, StakeholderMembership);
}

export interface SubjectMembership extends ParameterMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'SubjectMembership';
}

export const SubjectMembership = 'SubjectMembership';

export function isSubjectMembership(item: unknown): item is SubjectMembership {
    return reflection.isInstance(item, SubjectMembership);
}

export interface FramedConcernMembership extends RequirementConstraintMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'FramedConcernMembership';
}

export const FramedConcernMembership = 'FramedConcernMembership';

export function isFramedConcernMembership(item: unknown): item is FramedConcernMembership {
    return reflection.isInstance(item, FramedConcernMembership);
}

export interface RequirementVerificationMembership extends RequirementConstraintMembership {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'RequirementVerificationMembership';
}

export const RequirementVerificationMembership = 'RequirementVerificationMembership';

export function isRequirementVerificationMembership(item: unknown): item is RequirementVerificationMembership {
    return reflection.isInstance(item, RequirementVerificationMembership);
}

export interface ConjugatedPortTyping extends FeatureTyping {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ConjugatedPortTyping';
}

export const ConjugatedPortTyping = 'ConjugatedPortTyping';

export function isConjugatedPortTyping(item: unknown): item is ConjugatedPortTyping {
    return reflection.isInstance(item, ConjugatedPortTyping);
}

export interface Redefinition extends Subsetting {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Redefinition';
}

export const Redefinition = 'Redefinition';

export function isRedefinition(item: unknown): item is Redefinition {
    return reflection.isInstance(item, Redefinition);
}

export interface ReferenceSubsetting extends Subsetting {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ReferenceSubsetting';
}

export const ReferenceSubsetting = 'ReferenceSubsetting';

export function isReferenceSubsetting(item: unknown): item is ReferenceSubsetting {
    return reflection.isInstance(item, ReferenceSubsetting);
}

export interface ActionDefinition extends Behavior, OccurrenceDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ActionDefinition' | 'AnalysisCaseDefinition' | 'CalculationDefinition' | 'CaseDefinition' | 'FlowConnectionDefinition' | 'StateDefinition' | 'UseCaseDefinition' | 'VerificationCaseDefinition';
}

export const ActionDefinition = 'ActionDefinition';

export function isActionDefinition(item: unknown): item is ActionDefinition {
    return reflection.isInstance(item, ActionDefinition);
}

export interface SysMLFunction extends Behavior {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AnalysisCaseDefinition' | 'CalculationDefinition' | 'CaseDefinition' | 'ConcernDefinition' | 'ConstraintDefinition' | 'Predicate' | 'RequirementDefinition' | 'SysMLFunction' | 'UseCaseDefinition' | 'VerificationCaseDefinition' | 'ViewpointDefinition';
    result?: ResultExpressionMembership
}

export const SysMLFunction = 'SysMLFunction';

export function isSysMLFunction(item: unknown): item is SysMLFunction {
    return reflection.isInstance(item, SysMLFunction);
}

export interface ConstraintDefinition extends OccurrenceDefinition, Predicate {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ConcernDefinition' | 'ConstraintDefinition' | 'RequirementDefinition' | 'ViewpointDefinition';
}

export const ConstraintDefinition = 'ConstraintDefinition';

export function isConstraintDefinition(item: unknown): item is ConstraintDefinition {
    return reflection.isInstance(item, ConstraintDefinition);
}

export interface ItemDefinition extends OccurrenceDefinition, Structure {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationDefinition' | 'ConnectionDefinition' | 'FlowConnectionDefinition' | 'InterfaceDefinition' | 'ItemDefinition' | 'MetadataDefinition' | 'PartDefinition' | 'RenderingDefinition' | 'ViewDefinition';
}

export const ItemDefinition = 'ItemDefinition';

export function isItemDefinition(item: unknown): item is ItemDefinition {
    return reflection.isInstance(item, ItemDefinition);
}

export interface PortDefinition extends OccurrenceDefinition, Structure {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ConjugatedPortDefinition' | 'PortDefinition';
}

export const PortDefinition = 'PortDefinition';

export function isPortDefinition(item: unknown): item is PortDefinition {
    return reflection.isInstance(item, PortDefinition);
}

export interface Metaclass extends Structure {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'Metaclass' | 'MetadataDefinition';
}

export const Metaclass = 'Metaclass';

export function isMetaclass(item: unknown): item is Metaclass {
    return reflection.isInstance(item, Metaclass);
}

export interface EnumerationDefinition extends AttributeDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'EnumerationDefinition';
}

export const EnumerationDefinition = 'EnumerationDefinition';

export function isEnumerationDefinition(item: unknown): item is EnumerationDefinition {
    return reflection.isInstance(item, EnumerationDefinition);
}

export interface AcceptActionUsage extends ActionUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AcceptActionUsage';
    payload: ParameterMembership
    receiver?: ParameterMembership
}

export const AcceptActionUsage = 'AcceptActionUsage';

export function isAcceptActionUsage(item: unknown): item is AcceptActionUsage {
    return reflection.isInstance(item, AcceptActionUsage);
}

export interface AssignmentActionUsage extends ActionUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AssignmentActionUsage';
    assignedValue: ParameterMembership
    targetMember: Membership
}

export const AssignmentActionUsage = 'AssignmentActionUsage';

export function isAssignmentActionUsage(item: unknown): item is AssignmentActionUsage {
    return reflection.isInstance(item, AssignmentActionUsage);
}

export interface CalculationUsage extends ActionUsage, Expression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AnalysisCaseUsage' | 'CalculationUsage' | 'CaseUsage' | 'IncludeUseCaseUsage' | 'UseCaseUsage' | 'VerificationCaseUsage';
}

export const CalculationUsage = 'CalculationUsage';

export function isCalculationUsage(item: unknown): item is CalculationUsage {
    return reflection.isInstance(item, CalculationUsage);
}

export interface ControlNode extends ActionUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ControlNode' | 'DecisionNode' | 'ForkNode' | 'JoinNode' | 'MergeNode';
}

export const ControlNode = 'ControlNode';

export function isControlNode(item: unknown): item is ControlNode {
    return reflection.isInstance(item, ControlNode);
}

export interface IfActionUsage extends ActionUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'IfActionUsage';
    condition: ParameterMembership
    else?: ParameterMembership
    then: ParameterMembership
}

export const IfActionUsage = 'IfActionUsage';

export function isIfActionUsage(item: unknown): item is IfActionUsage {
    return reflection.isInstance(item, IfActionUsage);
}

export interface LoopActionUsage extends ActionUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ForLoopActionUsage' | 'LoopActionUsage' | 'WhileLoopActionUsage';
}

export const LoopActionUsage = 'LoopActionUsage';

export function isLoopActionUsage(item: unknown): item is LoopActionUsage {
    return reflection.isInstance(item, LoopActionUsage);
}

export interface PerformActionUsage extends ActionUsage, EventOccurrenceUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ExhibitStateUsage' | 'IncludeUseCaseUsage' | 'PerformActionUsage';
}

export const PerformActionUsage = 'PerformActionUsage';

export function isPerformActionUsage(item: unknown): item is PerformActionUsage {
    return reflection.isInstance(item, PerformActionUsage);
}

export interface SendActionUsage extends ActionUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'SendActionUsage';
    payload: ParameterMembership
    receiver?: ParameterMembership
    sender?: ParameterMembership
}

export const SendActionUsage = 'SendActionUsage';

export function isSendActionUsage(item: unknown): item is SendActionUsage {
    return reflection.isInstance(item, SendActionUsage);
}

export interface StateUsage extends ActionUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ExhibitStateUsage' | 'StateUsage';
    isParallel: boolean
}

export const StateUsage = 'StateUsage';

export function isStateUsage(item: unknown): item is StateUsage {
    return reflection.isInstance(item, StateUsage);
}

export interface TransitionUsage extends ActionUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'TransitionUsage';
    accepter?: TransitionFeatureMembership
    effect?: TransitionFeatureMembership
    else?: OwningMembership
    guard?: TransitionFeatureMembership
    payload?: ParameterMembership
    source?: Membership
    then?: OwningMembership
    transitionLinkSource?: ParameterMembership
}

export const TransitionUsage = 'TransitionUsage';

export function isTransitionUsage(item: unknown): item is TransitionUsage {
    return reflection.isInstance(item, TransitionUsage);
}

export interface BooleanExpression extends Expression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AssertConstraintUsage' | 'BooleanExpression' | 'ConcernUsage' | 'ConstraintUsage' | 'Invariant' | 'RequirementUsage' | 'SatisfyRequirementUsage' | 'ViewpointUsage';
}

export const BooleanExpression = 'BooleanExpression';

export function isBooleanExpression(item: unknown): item is BooleanExpression {
    return reflection.isInstance(item, BooleanExpression);
}

export interface FeatureReferenceExpression extends Expression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'FeatureReferenceExpression';
    expression: Membership
}

export const FeatureReferenceExpression = 'FeatureReferenceExpression';

export function isFeatureReferenceExpression(item: unknown): item is FeatureReferenceExpression {
    return reflection.isInstance(item, FeatureReferenceExpression);
}

export interface InvocationExpression extends Expression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'CollectExpression' | 'FeatureChainExpression' | 'InvocationExpression' | 'OperatorExpression' | 'SelectExpression' | 'TriggerInvocationExpression';
}

export const InvocationExpression = 'InvocationExpression';

export function isInvocationExpression(item: unknown): item is InvocationExpression {
    return reflection.isInstance(item, InvocationExpression);
}

export interface LiteralExpression extends Expression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'LiteralBoolean' | 'LiteralExpression' | 'LiteralInfinity' | 'LiteralNumber' | 'LiteralString';
}

export const LiteralExpression = 'LiteralExpression';

export function isLiteralExpression(item: unknown): item is LiteralExpression {
    return reflection.isInstance(item, LiteralExpression);
}

export interface MetadataAccessExpression extends Expression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'MetadataAccessExpression';
    reference: ElementReference
}

export const MetadataAccessExpression = 'MetadataAccessExpression';

export function isMetadataAccessExpression(item: unknown): item is MetadataAccessExpression {
    return reflection.isInstance(item, MetadataAccessExpression);
}

export interface NullExpression extends Expression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'NullExpression';
}

export const NullExpression = 'NullExpression';

export function isNullExpression(item: unknown): item is NullExpression {
    return reflection.isInstance(item, NullExpression);
}

export interface EnumerationUsage extends AttributeUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'EnumerationUsage';
}

export const EnumerationUsage = 'EnumerationUsage';

export function isEnumerationUsage(item: unknown): item is EnumerationUsage {
    return reflection.isInstance(item, EnumerationUsage);
}

export interface ConstraintUsage extends BooleanExpression, OccurrenceUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AssertConstraintUsage' | 'ConcernUsage' | 'ConstraintUsage' | 'RequirementUsage' | 'SatisfyRequirementUsage' | 'ViewpointUsage';
}

export const ConstraintUsage = 'ConstraintUsage';

export function isConstraintUsage(item: unknown): item is ConstraintUsage {
    return reflection.isInstance(item, ConstraintUsage);
}

export interface EventOccurrenceUsage extends OccurrenceUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'EventOccurrenceUsage' | 'ExhibitStateUsage' | 'IncludeUseCaseUsage' | 'PerformActionUsage';
}

export const EventOccurrenceUsage = 'EventOccurrenceUsage';

export function isEventOccurrenceUsage(item: unknown): item is EventOccurrenceUsage {
    return reflection.isInstance(item, EventOccurrenceUsage);
}

export interface ItemUsage extends OccurrenceUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationUsage' | 'ConnectionUsage' | 'FlowConnectionUsage' | 'InterfaceUsage' | 'ItemUsage' | 'MetadataUsage' | 'PartUsage' | 'RenderingUsage' | 'SuccessionFlowConnectionUsage' | 'ViewUsage';
}

export const ItemUsage = 'ItemUsage';

export function isItemUsage(item: unknown): item is ItemUsage {
    return reflection.isInstance(item, ItemUsage);
}

export interface PortUsage extends OccurrenceUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'PortUsage';
}

export const PortUsage = 'PortUsage';

export function isPortUsage(item: unknown): item is PortUsage {
    return reflection.isInstance(item, PortUsage);
}

export interface CalculationDefinition extends ActionDefinition, SysMLFunction {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AnalysisCaseDefinition' | 'CalculationDefinition' | 'CaseDefinition' | 'UseCaseDefinition' | 'VerificationCaseDefinition';
}

export const CalculationDefinition = 'CalculationDefinition';

export function isCalculationDefinition(item: unknown): item is CalculationDefinition {
    return reflection.isInstance(item, CalculationDefinition);
}

export interface StateDefinition extends ActionDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'StateDefinition';
    isParallel: boolean
}

export const StateDefinition = 'StateDefinition';

export function isStateDefinition(item: unknown): item is StateDefinition {
    return reflection.isInstance(item, StateDefinition);
}

export interface Predicate extends SysMLFunction {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ConcernDefinition' | 'ConstraintDefinition' | 'Predicate' | 'RequirementDefinition' | 'ViewpointDefinition';
}

export const Predicate = 'Predicate';

export function isPredicate(item: unknown): item is Predicate {
    return reflection.isInstance(item, Predicate);
}

export interface RequirementDefinition extends ConstraintDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ConcernDefinition' | 'RequirementDefinition' | 'ViewpointDefinition';
}

export const RequirementDefinition = 'RequirementDefinition';

export function isRequirementDefinition(item: unknown): item is RequirementDefinition {
    return reflection.isInstance(item, RequirementDefinition);
}

export interface MetadataDefinition extends ItemDefinition, Metaclass {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'MetadataDefinition';
}

export const MetadataDefinition = 'MetadataDefinition';

export function isMetadataDefinition(item: unknown): item is MetadataDefinition {
    return reflection.isInstance(item, MetadataDefinition);
}

export interface PartDefinition extends ItemDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationDefinition' | 'ConnectionDefinition' | 'FlowConnectionDefinition' | 'InterfaceDefinition' | 'PartDefinition' | 'RenderingDefinition' | 'ViewDefinition';
}

export const PartDefinition = 'PartDefinition';

export function isPartDefinition(item: unknown): item is PartDefinition {
    return reflection.isInstance(item, PartDefinition);
}

export interface ConjugatedPortDefinition extends PortDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ConjugatedPortDefinition';
}

export const ConjugatedPortDefinition = 'ConjugatedPortDefinition';

export function isConjugatedPortDefinition(item: unknown): item is ConjugatedPortDefinition {
    return reflection.isInstance(item, ConjugatedPortDefinition);
}

export interface CaseUsage extends CalculationUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AnalysisCaseUsage' | 'CaseUsage' | 'IncludeUseCaseUsage' | 'UseCaseUsage' | 'VerificationCaseUsage';
}

export const CaseUsage = 'CaseUsage';

export function isCaseUsage(item: unknown): item is CaseUsage {
    return reflection.isInstance(item, CaseUsage);
}

export interface DecisionNode extends ControlNode {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'DecisionNode';
}

export const DecisionNode = 'DecisionNode';

export function isDecisionNode(item: unknown): item is DecisionNode {
    return reflection.isInstance(item, DecisionNode);
}

export interface ForkNode extends ControlNode {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ForkNode';
}

export const ForkNode = 'ForkNode';

export function isForkNode(item: unknown): item is ForkNode {
    return reflection.isInstance(item, ForkNode);
}

export interface JoinNode extends ControlNode {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'JoinNode';
}

export const JoinNode = 'JoinNode';

export function isJoinNode(item: unknown): item is JoinNode {
    return reflection.isInstance(item, JoinNode);
}

export interface MergeNode extends ControlNode {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'MergeNode';
}

export const MergeNode = 'MergeNode';

export function isMergeNode(item: unknown): item is MergeNode {
    return reflection.isInstance(item, MergeNode);
}

export interface ForLoopActionUsage extends LoopActionUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ForLoopActionUsage';
    body: ParameterMembership
    sequence: ParameterMembership
    variable: ParameterMembership
}

export const ForLoopActionUsage = 'ForLoopActionUsage';

export function isForLoopActionUsage(item: unknown): item is ForLoopActionUsage {
    return reflection.isInstance(item, ForLoopActionUsage);
}

export interface WhileLoopActionUsage extends LoopActionUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'WhileLoopActionUsage';
    body: ParameterMembership
    condition?: ParameterMembership
    until?: ParameterMembership
}

export const WhileLoopActionUsage = 'WhileLoopActionUsage';

export function isWhileLoopActionUsage(item: unknown): item is WhileLoopActionUsage {
    return reflection.isInstance(item, WhileLoopActionUsage);
}

export interface ExhibitStateUsage extends PerformActionUsage, StateUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ExhibitStateUsage';
}

export const ExhibitStateUsage = 'ExhibitStateUsage';

export function isExhibitStateUsage(item: unknown): item is ExhibitStateUsage {
    return reflection.isInstance(item, ExhibitStateUsage);
}

export interface IncludeUseCaseUsage extends PerformActionUsage, UseCaseUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'IncludeUseCaseUsage';
}

export const IncludeUseCaseUsage = 'IncludeUseCaseUsage';

export function isIncludeUseCaseUsage(item: unknown): item is IncludeUseCaseUsage {
    return reflection.isInstance(item, IncludeUseCaseUsage);
}

export interface Invariant extends BooleanExpression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AssertConstraintUsage' | 'Invariant' | 'SatisfyRequirementUsage';
    isNegated: boolean
}

export const Invariant = 'Invariant';

export function isInvariant(item: unknown): item is Invariant {
    return reflection.isInstance(item, Invariant);
}

export interface OperatorExpression extends InvocationExpression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'CollectExpression' | 'FeatureChainExpression' | 'OperatorExpression' | 'SelectExpression';
    operands: Array<Expression>
    operator?: string
}

export const OperatorExpression = 'OperatorExpression';

export function isOperatorExpression(item: unknown): item is OperatorExpression {
    return reflection.isInstance(item, OperatorExpression);
}

export interface TriggerInvocationExpression extends InvocationExpression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'TriggerInvocationExpression';
    kind: 'after' | 'at' | 'when'
}

export const TriggerInvocationExpression = 'TriggerInvocationExpression';

export function isTriggerInvocationExpression(item: unknown): item is TriggerInvocationExpression {
    return reflection.isInstance(item, TriggerInvocationExpression);
}

export interface LiteralBoolean extends LiteralExpression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'LiteralBoolean';
    literal: boolean
}

export const LiteralBoolean = 'LiteralBoolean';

export function isLiteralBoolean(item: unknown): item is LiteralBoolean {
    return reflection.isInstance(item, LiteralBoolean);
}

export interface LiteralInfinity extends LiteralExpression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'LiteralInfinity';
}

export const LiteralInfinity = 'LiteralInfinity';

export function isLiteralInfinity(item: unknown): item is LiteralInfinity {
    return reflection.isInstance(item, LiteralInfinity);
}

export interface LiteralNumber extends LiteralExpression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'LiteralNumber';
    literal: number
}

export const LiteralNumber = 'LiteralNumber';

export function isLiteralNumber(item: unknown): item is LiteralNumber {
    return reflection.isInstance(item, LiteralNumber);
}

export interface LiteralString extends LiteralExpression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'LiteralString';
    literal: string
}

export const LiteralString = 'LiteralString';

export function isLiteralString(item: unknown): item is LiteralString {
    return reflection.isInstance(item, LiteralString);
}

export interface AssertConstraintUsage extends ConstraintUsage, Invariant {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AssertConstraintUsage' | 'SatisfyRequirementUsage';
}

export const AssertConstraintUsage = 'AssertConstraintUsage';

export function isAssertConstraintUsage(item: unknown): item is AssertConstraintUsage {
    return reflection.isInstance(item, AssertConstraintUsage);
}

export interface RequirementUsage extends ConstraintUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ConcernUsage' | 'RequirementUsage' | 'SatisfyRequirementUsage' | 'ViewpointUsage';
}

export const RequirementUsage = 'RequirementUsage';

export function isRequirementUsage(item: unknown): item is RequirementUsage {
    return reflection.isInstance(item, RequirementUsage);
}

export interface PartUsage extends ItemUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AllocationUsage' | 'ConnectionUsage' | 'FlowConnectionUsage' | 'InterfaceUsage' | 'PartUsage' | 'RenderingUsage' | 'SuccessionFlowConnectionUsage' | 'ViewUsage';
}

export const PartUsage = 'PartUsage';

export function isPartUsage(item: unknown): item is PartUsage {
    return reflection.isInstance(item, PartUsage);
}

export interface CaseDefinition extends CalculationDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AnalysisCaseDefinition' | 'CaseDefinition' | 'UseCaseDefinition' | 'VerificationCaseDefinition';
}

export const CaseDefinition = 'CaseDefinition';

export function isCaseDefinition(item: unknown): item is CaseDefinition {
    return reflection.isInstance(item, CaseDefinition);
}

export interface ConcernDefinition extends RequirementDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ConcernDefinition';
}

export const ConcernDefinition = 'ConcernDefinition';

export function isConcernDefinition(item: unknown): item is ConcernDefinition {
    return reflection.isInstance(item, ConcernDefinition);
}

export interface ViewpointDefinition extends RequirementDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ViewpointDefinition';
}

export const ViewpointDefinition = 'ViewpointDefinition';

export function isViewpointDefinition(item: unknown): item is ViewpointDefinition {
    return reflection.isInstance(item, ViewpointDefinition);
}

export interface RenderingDefinition extends PartDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'RenderingDefinition';
}

export const RenderingDefinition = 'RenderingDefinition';

export function isRenderingDefinition(item: unknown): item is RenderingDefinition {
    return reflection.isInstance(item, RenderingDefinition);
}

export interface ViewDefinition extends PartDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ViewDefinition';
}

export const ViewDefinition = 'ViewDefinition';

export function isViewDefinition(item: unknown): item is ViewDefinition {
    return reflection.isInstance(item, ViewDefinition);
}

export interface AnalysisCaseUsage extends CaseUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AnalysisCaseUsage';
}

export const AnalysisCaseUsage = 'AnalysisCaseUsage';

export function isAnalysisCaseUsage(item: unknown): item is AnalysisCaseUsage {
    return reflection.isInstance(item, AnalysisCaseUsage);
}

export interface UseCaseUsage extends CaseUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'IncludeUseCaseUsage' | 'UseCaseUsage';
}

export const UseCaseUsage = 'UseCaseUsage';

export function isUseCaseUsage(item: unknown): item is UseCaseUsage {
    return reflection.isInstance(item, UseCaseUsage);
}

export interface VerificationCaseUsage extends CaseUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'VerificationCaseUsage';
}

export const VerificationCaseUsage = 'VerificationCaseUsage';

export function isVerificationCaseUsage(item: unknown): item is VerificationCaseUsage {
    return reflection.isInstance(item, VerificationCaseUsage);
}

export interface CollectExpression extends OperatorExpression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'CollectExpression';
}

export const CollectExpression = 'CollectExpression';

export function isCollectExpression(item: unknown): item is CollectExpression {
    return reflection.isInstance(item, CollectExpression);
}

export interface FeatureChainExpression extends OperatorExpression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'FeatureChainExpression';
}

export const FeatureChainExpression = 'FeatureChainExpression';

export function isFeatureChainExpression(item: unknown): item is FeatureChainExpression {
    return reflection.isInstance(item, FeatureChainExpression);
}

export interface SelectExpression extends OperatorExpression {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'SelectExpression';
}

export const SelectExpression = 'SelectExpression';

export function isSelectExpression(item: unknown): item is SelectExpression {
    return reflection.isInstance(item, SelectExpression);
}

export interface SatisfyRequirementUsage extends AssertConstraintUsage, RequirementUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'SatisfyRequirementUsage';
    satisfactionSubject?: SubjectMembership
}

export const SatisfyRequirementUsage = 'SatisfyRequirementUsage';

export function isSatisfyRequirementUsage(item: unknown): item is SatisfyRequirementUsage {
    return reflection.isInstance(item, SatisfyRequirementUsage);
}

export interface ConcernUsage extends RequirementUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ConcernUsage';
}

export const ConcernUsage = 'ConcernUsage';

export function isConcernUsage(item: unknown): item is ConcernUsage {
    return reflection.isInstance(item, ConcernUsage);
}

export interface ViewpointUsage extends RequirementUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ViewpointUsage';
}

export const ViewpointUsage = 'ViewpointUsage';

export function isViewpointUsage(item: unknown): item is ViewpointUsage {
    return reflection.isInstance(item, ViewpointUsage);
}

export interface RenderingUsage extends PartUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'RenderingUsage';
}

export const RenderingUsage = 'RenderingUsage';

export function isRenderingUsage(item: unknown): item is RenderingUsage {
    return reflection.isInstance(item, RenderingUsage);
}

export interface ViewUsage extends PartUsage {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'ViewUsage';
}

export const ViewUsage = 'ViewUsage';

export function isViewUsage(item: unknown): item is ViewUsage {
    return reflection.isInstance(item, ViewUsage);
}

export interface AnalysisCaseDefinition extends CaseDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'AnalysisCaseDefinition';
}

export const AnalysisCaseDefinition = 'AnalysisCaseDefinition';

export function isAnalysisCaseDefinition(item: unknown): item is AnalysisCaseDefinition {
    return reflection.isInstance(item, AnalysisCaseDefinition);
}

export interface UseCaseDefinition extends CaseDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'UseCaseDefinition';
}

export const UseCaseDefinition = 'UseCaseDefinition';

export function isUseCaseDefinition(item: unknown): item is UseCaseDefinition {
    return reflection.isInstance(item, UseCaseDefinition);
}

export interface VerificationCaseDefinition extends CaseDefinition {
    readonly $container: AcceptActionUsage | AnnotatingElement | AssignmentActionUsage | Connector | Dependency | Expression | Feature | FeatureReferenceExpression | FlowConnectionUsage | ForLoopActionUsage | IfActionUsage | ItemFlow | MultiplicityRange | Namespace | OperatorExpression | Relationship | SatisfyRequirementUsage | SendActionUsage | SysMLFunction | TransitionUsage | Type | WhileLoopActionUsage;
    readonly $type: 'VerificationCaseDefinition';
}

export const VerificationCaseDefinition = 'VerificationCaseDefinition';

export function isVerificationCaseDefinition(item: unknown): item is VerificationCaseDefinition {
    return reflection.isInstance(item, VerificationCaseDefinition);
}

export type SysMlAstType = {
    AcceptActionUsage: AcceptActionUsage
    ActionDefinition: ActionDefinition
    ActionUsage: ActionUsage
    ActorMembership: ActorMembership
    AllocationDefinition: AllocationDefinition
    AllocationUsage: AllocationUsage
    AnalysisCaseDefinition: AnalysisCaseDefinition
    AnalysisCaseUsage: AnalysisCaseUsage
    AnnotatingElement: AnnotatingElement
    Annotation: Annotation
    AssertConstraintUsage: AssertConstraintUsage
    AssignmentActionUsage: AssignmentActionUsage
    Association: Association
    AssociationStructure: AssociationStructure
    AttributeDefinition: AttributeDefinition
    AttributeUsage: AttributeUsage
    Behavior: Behavior
    BindingConnector: BindingConnector
    BindingConnectorAsUsage: BindingConnectorAsUsage
    BooleanExpression: BooleanExpression
    CalculationDefinition: CalculationDefinition
    CalculationUsage: CalculationUsage
    CaseDefinition: CaseDefinition
    CaseUsage: CaseUsage
    Class: Class
    Classifier: Classifier
    ClassifierReference: ClassifierReference
    CollectExpression: CollectExpression
    Comment: Comment
    ConcernDefinition: ConcernDefinition
    ConcernUsage: ConcernUsage
    ConjugatedPortDefinition: ConjugatedPortDefinition
    ConjugatedPortReference: ConjugatedPortReference
    ConjugatedPortTyping: ConjugatedPortTyping
    Conjugation: Conjugation
    ConnectionDefinition: ConnectionDefinition
    ConnectionUsage: ConnectionUsage
    Connector: Connector
    ConnectorAsUsage: ConnectorAsUsage
    ConstraintDefinition: ConstraintDefinition
    ConstraintUsage: ConstraintUsage
    ControlNode: ControlNode
    DataType: DataType
    DecisionNode: DecisionNode
    Definition: Definition
    Dependency: Dependency
    Differencing: Differencing
    Disjoining: Disjoining
    Documentation: Documentation
    Element: Element
    ElementFilterMembership: ElementFilterMembership
    ElementReference: ElementReference
    EndFeatureMembership: EndFeatureMembership
    EnumerationDefinition: EnumerationDefinition
    EnumerationUsage: EnumerationUsage
    EventOccurrenceUsage: EventOccurrenceUsage
    ExhibitStateUsage: ExhibitStateUsage
    Expose: Expose
    Expression: Expression
    Feature: Feature
    FeatureChainExpression: FeatureChainExpression
    FeatureChaining: FeatureChaining
    FeatureInverting: FeatureInverting
    FeatureMembership: FeatureMembership
    FeatureReference: FeatureReference
    FeatureReferenceExpression: FeatureReferenceExpression
    FeatureRelationship: FeatureRelationship
    FeatureTyping: FeatureTyping
    FeatureValue: FeatureValue
    Featuring: Featuring
    FlowConnectionDefinition: FlowConnectionDefinition
    FlowConnectionUsage: FlowConnectionUsage
    ForLoopActionUsage: ForLoopActionUsage
    ForkNode: ForkNode
    FramedConcernMembership: FramedConcernMembership
    IfActionUsage: IfActionUsage
    Import: Import
    IncludeUseCaseUsage: IncludeUseCaseUsage
    Inheritance: Inheritance
    InlineExpression: InlineExpression
    Interaction: Interaction
    InterfaceDefinition: InterfaceDefinition
    InterfaceUsage: InterfaceUsage
    Intersecting: Intersecting
    Invariant: Invariant
    InvocationExpression: InvocationExpression
    ItemDefinition: ItemDefinition
    ItemFeature: ItemFeature
    ItemFlow: ItemFlow
    ItemFlowEnd: ItemFlowEnd
    ItemUsage: ItemUsage
    JoinNode: JoinNode
    LibraryPackage: LibraryPackage
    LifeClass: LifeClass
    LiteralBoolean: LiteralBoolean
    LiteralExpression: LiteralExpression
    LiteralInfinity: LiteralInfinity
    LiteralNumber: LiteralNumber
    LiteralString: LiteralString
    LoopActionUsage: LoopActionUsage
    Membership: Membership
    MembershipExpose: MembershipExpose
    MembershipImport: MembershipImport
    MembershipReference: MembershipReference
    MergeNode: MergeNode
    Metaclass: Metaclass
    MetaclassReference: MetaclassReference
    MetadataAccessExpression: MetadataAccessExpression
    MetadataDefinition: MetadataDefinition
    MetadataFeature: MetadataFeature
    MetadataUsage: MetadataUsage
    Multiplicity: Multiplicity
    MultiplicityRange: MultiplicityRange
    Namespace: Namespace
    NamespaceExpose: NamespaceExpose
    NamespaceImport: NamespaceImport
    NamespaceReference: NamespaceReference
    NonOwnerType: NonOwnerType
    NullExpression: NullExpression
    ObjectiveMembership: ObjectiveMembership
    OccurrenceDefinition: OccurrenceDefinition
    OccurrenceUsage: OccurrenceUsage
    OperatorExpression: OperatorExpression
    OwningMembership: OwningMembership
    Package: Package
    ParameterMembership: ParameterMembership
    PartDefinition: PartDefinition
    PartUsage: PartUsage
    PerformActionUsage: PerformActionUsage
    PortConjugation: PortConjugation
    PortDefinition: PortDefinition
    PortUsage: PortUsage
    Predicate: Predicate
    Redefinition: Redefinition
    ReferenceSubsetting: ReferenceSubsetting
    ReferenceUsage: ReferenceUsage
    Relationship: Relationship
    RenderingDefinition: RenderingDefinition
    RenderingUsage: RenderingUsage
    RequirementConstraintMembership: RequirementConstraintMembership
    RequirementDefinition: RequirementDefinition
    RequirementUsage: RequirementUsage
    RequirementVerificationMembership: RequirementVerificationMembership
    ResultExpressionMembership: ResultExpressionMembership
    ReturnParameterMembership: ReturnParameterMembership
    SatisfyRequirementUsage: SatisfyRequirementUsage
    SelectExpression: SelectExpression
    SendActionUsage: SendActionUsage
    Specialization: Specialization
    StakeholderMembership: StakeholderMembership
    StateDefinition: StateDefinition
    StateSubactionMembership: StateSubactionMembership
    StateUsage: StateUsage
    Step: Step
    Structure: Structure
    Subclassification: Subclassification
    SubjectMembership: SubjectMembership
    Subsetting: Subsetting
    Succession: Succession
    SuccessionAsUsage: SuccessionAsUsage
    SuccessionFlowConnectionUsage: SuccessionFlowConnectionUsage
    SuccessionItemFlow: SuccessionItemFlow
    SysMLFunction: SysMLFunction
    TextualAnnotatingElement: TextualAnnotatingElement
    TextualRepresentation: TextualRepresentation
    TransitionFeatureMembership: TransitionFeatureMembership
    TransitionUsage: TransitionUsage
    TransparentElement: TransparentElement
    TriggerInvocationExpression: TriggerInvocationExpression
    Type: Type
    TypeFeaturing: TypeFeaturing
    TypeReference: TypeReference
    TypeRelationship: TypeRelationship
    Unioning: Unioning
    Usage: Usage
    UseCaseDefinition: UseCaseDefinition
    UseCaseUsage: UseCaseUsage
    VariantMembership: VariantMembership
    VerificationCaseDefinition: VerificationCaseDefinition
    VerificationCaseUsage: VerificationCaseUsage
    ViewDefinition: ViewDefinition
    ViewRenderingMembership: ViewRenderingMembership
    ViewUsage: ViewUsage
    ViewpointDefinition: ViewpointDefinition
    ViewpointUsage: ViewpointUsage
    WhileLoopActionUsage: WhileLoopActionUsage
}

export class SysMlAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AcceptActionUsage', 'ActionDefinition', 'ActionUsage', 'ActorMembership', 'AllocationDefinition', 'AllocationUsage', 'AnalysisCaseDefinition', 'AnalysisCaseUsage', 'AnnotatingElement', 'Annotation', 'AssertConstraintUsage', 'AssignmentActionUsage', 'Association', 'AssociationStructure', 'AttributeDefinition', 'AttributeUsage', 'Behavior', 'BindingConnector', 'BindingConnectorAsUsage', 'BooleanExpression', 'CalculationDefinition', 'CalculationUsage', 'CaseDefinition', 'CaseUsage', 'Class', 'Classifier', 'ClassifierReference', 'CollectExpression', 'Comment', 'ConcernDefinition', 'ConcernUsage', 'ConjugatedPortDefinition', 'ConjugatedPortReference', 'ConjugatedPortTyping', 'Conjugation', 'ConnectionDefinition', 'ConnectionUsage', 'Connector', 'ConnectorAsUsage', 'ConstraintDefinition', 'ConstraintUsage', 'ControlNode', 'DataType', 'DecisionNode', 'Definition', 'Dependency', 'Differencing', 'Disjoining', 'Documentation', 'Element', 'ElementFilterMembership', 'ElementReference', 'EndFeatureMembership', 'EnumerationDefinition', 'EnumerationUsage', 'EventOccurrenceUsage', 'ExhibitStateUsage', 'Expose', 'Expression', 'Feature', 'FeatureChainExpression', 'FeatureChaining', 'FeatureInverting', 'FeatureMembership', 'FeatureReference', 'FeatureReferenceExpression', 'FeatureRelationship', 'FeatureTyping', 'FeatureValue', 'Featuring', 'FlowConnectionDefinition', 'FlowConnectionUsage', 'ForLoopActionUsage', 'ForkNode', 'FramedConcernMembership', 'IfActionUsage', 'Import', 'IncludeUseCaseUsage', 'Inheritance', 'InlineExpression', 'Interaction', 'InterfaceDefinition', 'InterfaceUsage', 'Intersecting', 'Invariant', 'InvocationExpression', 'ItemDefinition', 'ItemFeature', 'ItemFlow', 'ItemFlowEnd', 'ItemUsage', 'JoinNode', 'LibraryPackage', 'LifeClass', 'LiteralBoolean', 'LiteralExpression', 'LiteralInfinity', 'LiteralNumber', 'LiteralString', 'LoopActionUsage', 'Membership', 'MembershipExpose', 'MembershipImport', 'MembershipReference', 'MergeNode', 'Metaclass', 'MetaclassReference', 'MetadataAccessExpression', 'MetadataDefinition', 'MetadataFeature', 'MetadataUsage', 'Multiplicity', 'MultiplicityRange', 'Namespace', 'NamespaceExpose', 'NamespaceImport', 'NamespaceReference', 'NonOwnerType', 'NullExpression', 'ObjectiveMembership', 'OccurrenceDefinition', 'OccurrenceUsage', 'OperatorExpression', 'OwningMembership', 'Package', 'ParameterMembership', 'PartDefinition', 'PartUsage', 'PerformActionUsage', 'PortConjugation', 'PortDefinition', 'PortUsage', 'Predicate', 'Redefinition', 'ReferenceSubsetting', 'ReferenceUsage', 'Relationship', 'RenderingDefinition', 'RenderingUsage', 'RequirementConstraintMembership', 'RequirementDefinition', 'RequirementUsage', 'RequirementVerificationMembership', 'ResultExpressionMembership', 'ReturnParameterMembership', 'SatisfyRequirementUsage', 'SelectExpression', 'SendActionUsage', 'Specialization', 'StakeholderMembership', 'StateDefinition', 'StateSubactionMembership', 'StateUsage', 'Step', 'Structure', 'Subclassification', 'SubjectMembership', 'Subsetting', 'Succession', 'SuccessionAsUsage', 'SuccessionFlowConnectionUsage', 'SuccessionItemFlow', 'SysMLFunction', 'TextualAnnotatingElement', 'TextualRepresentation', 'TransitionFeatureMembership', 'TransitionUsage', 'TransparentElement', 'TriggerInvocationExpression', 'Type', 'TypeFeaturing', 'TypeReference', 'TypeRelationship', 'Unioning', 'Usage', 'UseCaseDefinition', 'UseCaseUsage', 'VariantMembership', 'VerificationCaseDefinition', 'VerificationCaseUsage', 'ViewDefinition', 'ViewRenderingMembership', 'ViewUsage', 'ViewpointDefinition', 'ViewpointUsage', 'WhileLoopActionUsage'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case AcceptActionUsage:
            case AssignmentActionUsage:
            case ControlNode:
            case IfActionUsage:
            case SendActionUsage:
            case StateUsage:
            case TransitionUsage: {
                return this.isSubtype(ActionUsage, supertype);
            }
            case ActionDefinition: {
                return this.isSubtype(Behavior, supertype) || this.isSubtype(OccurrenceDefinition, supertype);
            }
            case ActionUsage: {
                return this.isSubtype(OccurrenceUsage, supertype) || this.isSubtype(Step, supertype);
            }
            case ActorMembership:
            case ReturnParameterMembership:
            case StakeholderMembership:
            case SubjectMembership: {
                return this.isSubtype(ParameterMembership, supertype);
            }
            case AllocationDefinition:
            case InterfaceDefinition: {
                return this.isSubtype(ConnectionDefinition, supertype);
            }
            case AllocationUsage:
            case InterfaceUsage: {
                return this.isSubtype(ConnectionUsage, supertype);
            }
            case AnalysisCaseDefinition:
            case UseCaseDefinition:
            case VerificationCaseDefinition: {
                return this.isSubtype(CaseDefinition, supertype);
            }
            case AnalysisCaseUsage:
            case UseCaseUsage:
            case VerificationCaseUsage: {
                return this.isSubtype(CaseUsage, supertype);
            }
            case AnnotatingElement:
            case Namespace:
            case Relationship: {
                return this.isSubtype(Element, supertype);
            }
            case Annotation:
            case Membership: {
                return this.isSubtype(NonOwnerType, supertype) || this.isSubtype(Relationship, supertype);
            }
            case AssertConstraintUsage: {
                return this.isSubtype(ConstraintUsage, supertype) || this.isSubtype(Invariant, supertype);
            }
            case Association: {
                return this.isSubtype(Classifier, supertype) || this.isSubtype(Relationship, supertype);
            }
            case AssociationStructure: {
                return this.isSubtype(Association, supertype) || this.isSubtype(Structure, supertype);
            }
            case AttributeDefinition: {
                return this.isSubtype(DataType, supertype) || this.isSubtype(Definition, supertype);
            }
            case AttributeUsage:
            case OccurrenceUsage:
            case ReferenceUsage: {
                return this.isSubtype(Usage, supertype);
            }
            case Behavior:
            case LifeClass:
            case Structure: {
                return this.isSubtype(Class, supertype);
            }
            case BindingConnector:
            case Succession: {
                return this.isSubtype(Connector, supertype);
            }
            case BindingConnectorAsUsage: {
                return this.isSubtype(BindingConnector, supertype) || this.isSubtype(ConnectorAsUsage, supertype);
            }
            case BooleanExpression: {
                return this.isSubtype(Expression, supertype);
            }
            case CalculationDefinition: {
                return this.isSubtype(ActionDefinition, supertype) || this.isSubtype(SysMLFunction, supertype);
            }
            case CalculationUsage: {
                return this.isSubtype(ActionUsage, supertype) || this.isSubtype(Expression, supertype);
            }
            case CaseDefinition: {
                return this.isSubtype(CalculationDefinition, supertype);
            }
            case CaseUsage: {
                return this.isSubtype(CalculationUsage, supertype);
            }
            case Class:
            case DataType:
            case Definition: {
                return this.isSubtype(Classifier, supertype);
            }
            case Classifier:
            case Feature: {
                return this.isSubtype(Type, supertype);
            }
            case ClassifierReference:
            case FeatureReference: {
                return this.isSubtype(TypeReference, supertype);
            }
            case CollectExpression:
            case FeatureChainExpression:
            case SelectExpression: {
                return this.isSubtype(InlineExpression, supertype) || this.isSubtype(OperatorExpression, supertype);
            }
            case Comment:
            case TextualRepresentation: {
                return this.isSubtype(TextualAnnotatingElement, supertype);
            }
            case ConcernDefinition:
            case ViewpointDefinition: {
                return this.isSubtype(RequirementDefinition, supertype);
            }
            case ConcernUsage:
            case ViewpointUsage: {
                return this.isSubtype(RequirementUsage, supertype);
            }
            case ConjugatedPortDefinition: {
                return this.isSubtype(PortDefinition, supertype);
            }
            case ConjugatedPortReference:
            case MetaclassReference: {
                return this.isSubtype(ClassifierReference, supertype);
            }
            case ConjugatedPortTyping: {
                return this.isSubtype(FeatureTyping, supertype);
            }
            case Conjugation:
            case Specialization: {
                return this.isSubtype(Inheritance, supertype);
            }
            case ConnectionDefinition: {
                return this.isSubtype(AssociationStructure, supertype) || this.isSubtype(PartDefinition, supertype);
            }
            case ConnectionUsage: {
                return this.isSubtype(ConnectorAsUsage, supertype) || this.isSubtype(PartUsage, supertype);
            }
            case Connector: {
                return this.isSubtype(Feature, supertype) || this.isSubtype(Relationship, supertype);
            }
            case ConnectorAsUsage: {
                return this.isSubtype(Connector, supertype) || this.isSubtype(Usage, supertype);
            }
            case ConstraintDefinition: {
                return this.isSubtype(OccurrenceDefinition, supertype) || this.isSubtype(Predicate, supertype);
            }
            case ConstraintUsage: {
                return this.isSubtype(BooleanExpression, supertype) || this.isSubtype(OccurrenceUsage, supertype);
            }
            case DecisionNode:
            case ForkNode:
            case JoinNode:
            case MergeNode: {
                return this.isSubtype(ControlNode, supertype);
            }
            case Dependency:
            case Featuring:
            case Import:
            case Inheritance: {
                return this.isSubtype(Relationship, supertype);
            }
            case Differencing:
            case Disjoining:
            case Intersecting:
            case Unioning: {
                return this.isSubtype(Relationship, supertype) || this.isSubtype(TypeRelationship, supertype);
            }
            case Documentation: {
                return this.isSubtype(Comment, supertype);
            }
            case ElementFilterMembership:
            case FeatureValue:
            case VariantMembership: {
                return this.isSubtype(OwningMembership, supertype);
            }
            case EndFeatureMembership:
            case ObjectiveMembership:
            case ParameterMembership:
            case RequirementConstraintMembership:
            case ResultExpressionMembership:
            case StateSubactionMembership:
            case TransitionFeatureMembership:
            case ViewRenderingMembership: {
                return this.isSubtype(FeatureMembership, supertype);
            }
            case EnumerationDefinition: {
                return this.isSubtype(AttributeDefinition, supertype);
            }
            case EnumerationUsage: {
                return this.isSubtype(AttributeUsage, supertype);
            }
            case EventOccurrenceUsage:
            case ItemUsage:
            case PortUsage: {
                return this.isSubtype(OccurrenceUsage, supertype);
            }
            case ExhibitStateUsage: {
                return this.isSubtype(PerformActionUsage, supertype) || this.isSubtype(StateUsage, supertype);
            }
            case Expose:
            case MembershipImport:
            case NamespaceImport: {
                return this.isSubtype(Import, supertype);
            }
            case Expression: {
                return this.isSubtype(Step, supertype);
            }
            case FeatureChaining:
            case FeatureInverting: {
                return this.isSubtype(FeatureRelationship, supertype) || this.isSubtype(Relationship, supertype);
            }
            case FeatureMembership: {
                return this.isSubtype(Featuring, supertype) || this.isSubtype(OwningMembership, supertype);
            }
            case FeatureReferenceExpression:
            case InvocationExpression:
            case LiteralExpression:
            case MetadataAccessExpression:
            case NullExpression: {
                return this.isSubtype(Expression, supertype) || this.isSubtype(InlineExpression, supertype);
            }
            case FeatureTyping:
            case Subclassification:
            case Subsetting: {
                return this.isSubtype(Specialization, supertype);
            }
            case FlowConnectionDefinition: {
                return this.isSubtype(ActionDefinition, supertype) || this.isSubtype(ConnectionDefinition, supertype) || this.isSubtype(Interaction, supertype);
            }
            case FlowConnectionUsage: {
                return this.isSubtype(ActionUsage, supertype) || this.isSubtype(ConnectionUsage, supertype) || this.isSubtype(ItemFlow, supertype);
            }
            case ForLoopActionUsage:
            case WhileLoopActionUsage: {
                return this.isSubtype(LoopActionUsage, supertype);
            }
            case FramedConcernMembership:
            case RequirementVerificationMembership: {
                return this.isSubtype(RequirementConstraintMembership, supertype);
            }
            case IncludeUseCaseUsage: {
                return this.isSubtype(PerformActionUsage, supertype) || this.isSubtype(UseCaseUsage, supertype);
            }
            case Interaction: {
                return this.isSubtype(Association, supertype) || this.isSubtype(Behavior, supertype);
            }
            case Invariant: {
                return this.isSubtype(BooleanExpression, supertype);
            }
            case ItemDefinition:
            case PortDefinition: {
                return this.isSubtype(OccurrenceDefinition, supertype) || this.isSubtype(Structure, supertype);
            }
            case ItemFeature:
            case ItemFlowEnd:
            case Multiplicity:
            case Step:
            case Usage: {
                return this.isSubtype(Feature, supertype);
            }
            case ItemFlow: {
                return this.isSubtype(Connector, supertype) || this.isSubtype(Step, supertype);
            }
            case LibraryPackage: {
                return this.isSubtype(Package, supertype);
            }
            case LiteralBoolean:
            case LiteralInfinity:
            case LiteralNumber:
            case LiteralString: {
                return this.isSubtype(LiteralExpression, supertype);
            }
            case LoopActionUsage: {
                return this.isSubtype(ActionUsage, supertype) || this.isSubtype(TransparentElement, supertype);
            }
            case MembershipExpose: {
                return this.isSubtype(Expose, supertype) || this.isSubtype(MembershipImport, supertype);
            }
            case MembershipReference:
            case NamespaceReference: {
                return this.isSubtype(ElementReference, supertype);
            }
            case Metaclass: {
                return this.isSubtype(Structure, supertype);
            }
            case MetadataDefinition: {
                return this.isSubtype(ItemDefinition, supertype) || this.isSubtype(Metaclass, supertype);
            }
            case MetadataFeature: {
                return this.isSubtype(AnnotatingElement, supertype) || this.isSubtype(Feature, supertype);
            }
            case MetadataUsage: {
                return this.isSubtype(ItemUsage, supertype) || this.isSubtype(MetadataFeature, supertype);
            }
            case MultiplicityRange: {
                return this.isSubtype(Multiplicity, supertype);
            }
            case NamespaceExpose: {
                return this.isSubtype(Expose, supertype) || this.isSubtype(NamespaceImport, supertype);
            }
            case NonOwnerType: {
                return this.isSubtype(TransparentElement, supertype);
            }
            case OccurrenceDefinition: {
                return this.isSubtype(Class, supertype) || this.isSubtype(Definition, supertype);
            }
            case OperatorExpression: {
                return this.isSubtype(InlineExpression, supertype) || this.isSubtype(InvocationExpression, supertype);
            }
            case OwningMembership: {
                return this.isSubtype(Membership, supertype);
            }
            case Package:
            case Type: {
                return this.isSubtype(Namespace, supertype);
            }
            case PartDefinition: {
                return this.isSubtype(ItemDefinition, supertype);
            }
            case PartUsage: {
                return this.isSubtype(ItemUsage, supertype);
            }
            case PerformActionUsage: {
                return this.isSubtype(ActionUsage, supertype) || this.isSubtype(EventOccurrenceUsage, supertype);
            }
            case PortConjugation: {
                return this.isSubtype(Conjugation, supertype);
            }
            case Predicate: {
                return this.isSubtype(SysMLFunction, supertype);
            }
            case Redefinition:
            case ReferenceSubsetting: {
                return this.isSubtype(Subsetting, supertype);
            }
            case RenderingDefinition:
            case ViewDefinition: {
                return this.isSubtype(PartDefinition, supertype);
            }
            case RenderingUsage:
            case ViewUsage: {
                return this.isSubtype(PartUsage, supertype);
            }
            case RequirementDefinition: {
                return this.isSubtype(ConstraintDefinition, supertype);
            }
            case RequirementUsage: {
                return this.isSubtype(ConstraintUsage, supertype);
            }
            case SatisfyRequirementUsage: {
                return this.isSubtype(AssertConstraintUsage, supertype) || this.isSubtype(RequirementUsage, supertype);
            }
            case StateDefinition: {
                return this.isSubtype(ActionDefinition, supertype);
            }
            case SuccessionAsUsage: {
                return this.isSubtype(ConnectorAsUsage, supertype) || this.isSubtype(Succession, supertype);
            }
            case SuccessionFlowConnectionUsage: {
                return this.isSubtype(FlowConnectionUsage, supertype) || this.isSubtype(SuccessionItemFlow, supertype);
            }
            case SuccessionItemFlow: {
                return this.isSubtype(ItemFlow, supertype) || this.isSubtype(Succession, supertype);
            }
            case SysMLFunction: {
                return this.isSubtype(Behavior, supertype);
            }
            case TextualAnnotatingElement: {
                return this.isSubtype(AnnotatingElement, supertype);
            }
            case TriggerInvocationExpression: {
                return this.isSubtype(InvocationExpression, supertype);
            }
            case TypeFeaturing: {
                return this.isSubtype(FeatureRelationship, supertype) || this.isSubtype(Featuring, supertype);
            }
            case TypeReference: {
                return this.isSubtype(NamespaceReference, supertype);
            }
            case TypeRelationship: {
                return this.isSubtype(FeatureRelationship, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'ClassifierReference:parts':
            case 'ConjugatedPortReference:parts':
            case 'ElementReference:parts':
            case 'FeatureReference:parts':
            case 'MembershipReference:parts':
            case 'MetaclassReference:parts':
            case 'NamespaceReference:parts':
            case 'TypeReference:parts': {
                return Element;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'ElementReference': {
                return {
                    name: 'ElementReference',
                    mandatory: [
                        { name: 'parts', type: 'array' }
                    ]
                };
            }
            case 'AnnotatingElement': {
                return {
                    name: 'AnnotatingElement',
                    mandatory: [
                        { name: 'about', type: 'array' }
                    ]
                };
            }
            case 'Namespace': {
                return {
                    name: 'Namespace',
                    mandatory: [
                        { name: 'children', type: 'array' },
                        { name: 'prefixes', type: 'array' }
                    ]
                };
            }
            case 'Relationship': {
                return {
                    name: 'Relationship',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'Type': {
                return {
                    name: 'Type',
                    mandatory: [
                        { name: 'heritage', type: 'array' },
                        { name: 'isSufficient', type: 'boolean' },
                        { name: 'typeRelationships', type: 'array' }
                    ]
                };
            }
            case 'Connector': {
                return {
                    name: 'Connector',
                    mandatory: [
                        { name: 'ends', type: 'array' }
                    ]
                };
            }
            case 'Dependency': {
                return {
                    name: 'Dependency',
                    mandatory: [
                        { name: 'client', type: 'array' },
                        { name: 'prefixes', type: 'array' },
                        { name: 'supplier', type: 'array' }
                    ]
                };
            }
            case 'Import': {
                return {
                    name: 'Import',
                    mandatory: [
                        { name: 'importsAll', type: 'boolean' },
                        { name: 'isRecursive', type: 'boolean' }
                    ]
                };
            }
            case 'Membership': {
                return {
                    name: 'Membership',
                    mandatory: [
                        { name: 'isAlias', type: 'boolean' }
                    ]
                };
            }
            case 'LibraryPackage': {
                return {
                    name: 'LibraryPackage',
                    mandatory: [
                        { name: 'isStandard', type: 'boolean' }
                    ]
                };
            }
            case 'Feature': {
                return {
                    name: 'Feature',
                    mandatory: [
                        { name: 'isNonunique', type: 'boolean' },
                        { name: 'isOrdered', type: 'boolean' }
                    ]
                };
            }
            case 'Definition': {
                return {
                    name: 'Definition',
                    mandatory: [
                        { name: 'isIndividual', type: 'boolean' },
                        { name: 'isVariation', type: 'boolean' }
                    ]
                };
            }
            case 'Usage': {
                return {
                    name: 'Usage',
                    mandatory: [
                        { name: 'isIndividual', type: 'boolean' },
                        { name: 'isReference', type: 'boolean' },
                        { name: 'isVariation', type: 'boolean' }
                    ]
                };
            }
            case 'FlowConnectionUsage': {
                return {
                    name: 'FlowConnectionUsage',
                    mandatory: [
                        { name: 'messages', type: 'array' }
                    ]
                };
            }
            case 'FeatureValue': {
                return {
                    name: 'FeatureValue',
                    mandatory: [
                        { name: 'isDefault', type: 'boolean' },
                        { name: 'isInitial', type: 'boolean' }
                    ]
                };
            }
            case 'StateUsage': {
                return {
                    name: 'StateUsage',
                    mandatory: [
                        { name: 'isParallel', type: 'boolean' }
                    ]
                };
            }
            case 'StateDefinition': {
                return {
                    name: 'StateDefinition',
                    mandatory: [
                        { name: 'isParallel', type: 'boolean' }
                    ]
                };
            }
            case 'Invariant': {
                return {
                    name: 'Invariant',
                    mandatory: [
                        { name: 'isNegated', type: 'boolean' }
                    ]
                };
            }
            case 'OperatorExpression': {
                return {
                    name: 'OperatorExpression',
                    mandatory: [
                        { name: 'operands', type: 'array' }
                    ]
                };
            }
            case 'LiteralBoolean': {
                return {
                    name: 'LiteralBoolean',
                    mandatory: [
                        { name: 'literal', type: 'boolean' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new SysMlAstReflection();
